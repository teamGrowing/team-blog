{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"비동기 처리를 ‘잘’ 해보자. 비동기 처리는 프론트엔드 개발에서 피할 수 없는 중요한 부분이에요. 특히 사용자 경험(UX)에 큰 영향을 미치는데요, 사용자에게 끊김 없는 경험을 제공하기 위해서는 로딩, 성공, 상태 등 비동기 작업의 상태를 적절하게 관리하고 표현하는 것이 필수적이죠. 이번 글에서는 그로잉 팀의 비동기 처리와 사용자 경험(UX) 향상 전략에…","fields":{"slug":"/asynchronous-processing/"},"frontmatter":{"date":"March 05, 2024","title":"로딩에 실패했습니다. 어떻게 처리하실건가요?","tags":["growing","asynchrounous-processing","suspense","error-boundary"]},"rawMarkdownBody":"\n## 비동기 처리를 ‘잘’ 해보자.\n\n비동기 처리는 프론트엔드 개발에서 피할 수 없는 중요한 부분이에요.\n\n특히 사용자 경험(UX)에 큰 영향을 미치는데요, 사용자에게 끊김 없는 경험을 제공하기 위해서는 로딩, 성공, 상태 등 비동기 작업의 상태를 적절하게 관리하고 표현하는 것이 필수적이죠.\n\n이번 글에서는 그로잉 팀의 비동기 처리와 사용자 경험(UX) 향상 전략에 대해 소개할게요.\n\n## 문제점1: 프론트엔드에서 비동기 처리 로직을 깔끔히 처리하긴 쉽지 않다.\n\n프론트엔드에서 비동기 처리 로직을 깔끔하게 처리하는 건 생각보다 쉽지 않아요. 다양한 상황을 고려해야 하기 때문이죠.\n\n데이터를 불러오는 동안 사용자에게 로딩 상태를 표시해줘야 하고, 요청이 실패하거나 네트워크 문제가 발생했을 때는 이를 알려줘야 합니다. 또한, 요청이 성공적으로 완료되었을 때에는 받아온 데이터를 UI에 적절하게 표시해줘야 해요.\n\n이러한 모든 상황을 각각의 컴포넌트 내에서 처리하려고 하면, 코드가 금방 복잡해지고 관리하기 어려워지곤 해요. 특히, 여러 비동기 요청을 동시에 처리해야 하는 경우나, 상태에 따른 다양한 UI 변화를 관리해야 하는 경우에는 더욱 그렇죠.\n\n보통 아래와 같이 한 컴포넌트 내에서 로딩과 에러 처리를 동시에 수행하는 경우를 많이 봤을 거에요.\n\n```jsx\nconst Profile = () => {\n  const { data: profile, isError, isLoading } = useQuery([\"profile\"], fetchFoo)\n\n  if (isError) return <div>로딩에 실패했습니다.</div>\n  if (!isLoading) return <div>로딩 중입니다...</div>\n  return <div>{profile?.name}님 안녕하세요!</div>\n}\n```\n\n그러나 이는 관리해야할 로딩, 에러 상태가 많아질수록 코드의 가독성을 저하시킬 수 있으며 복잡한 컴포넌트가 될 가능성이 커지는 구조입니다.\n\n## 문제점2: 적절하지 못한 비동기 처리는 성능 저하를 불러일으킨다.\n\n또한 비동기 상태를 적절히 처리하지 않으면, 다른 개발자 뿐만 아니라 사용자에게 좋지 않은 경험을 줄 수 있어요.\n\n그로잉 프로젝트에서는 이러한 로딩, 에러가 적절하게 처리되지 않고 있었는데요, 기존의 그로잉 프로젝트의 상황을 알아볼게요.\n\n### 1. 부정적인 사용자 경험\n\n<img src='./images/home-undefined.png' />\n\n기존에 그로잉 프로젝트에서는 데이터를 불러오기 전까지 별다른 처리를 하지 않았어요. 그래서 이 데이터가 필요한 곳은 데이터를 다 받아올 때까지 비어있어야 했습니다. 그래서 위 사진처럼 `undefined` 키워드가 잠시 노출되다가 불러온 데이터로 해당 부분이 채워졌어요.\n\n이는 사용자 입장에서 매우 혼란스러울 수 있어요. 사용자들은 이해하기 쉬운 정보를 기대하는데 `undefined`와 같은 용어가 그대로 보여진다면 사용자 경험(UX)에 부정적인 영향을 미칠 수 있습니다.\n\n### 2. CLS에 악영향\n\n![](./images/not-good-cls.png)\n\n또한 콘텐츠가 로딩되는 동안 예기치 못한 레이아웃 이동이 일어날 수 있어요. 이를 수치화한 것을 `CLS(Cumulative Layout Shift)`라고 합니다.\n\n위 사진은 그로잉 프로젝트에서 크롬 개발자도구의 Lighthouse를 사용해 성능을 측정한 사진이에요. 개선해야 할 다른 부분들도 많지만, `CLS(Cumulative Layout Shift)` 항목에서도 좋은 점수를 받지 못하고 있다는 것을 알 수 있었어요.\n\n## 이를 Suspense와 Error Boundary를 이용하여 해결해보자!\n\nReact는 컴포넌트의 로딩 상태와 에러 처리를 선언적으로 관리할 수 있도록 [Suspense](https://react.dev/reference/react/Suspense)와 [Error Boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)를 제공하고 있는데요, 저희 그로잉 팀은 앞선 문제들을 해결하고자 이를 활용하기로 했어요.\n\n두 개념에 대해 더 자세히 알아볼게요.\n\n### Suspense\n\n`Suspense`는 React가 비동기 작업(예: 데이터 가져오기)이 끝날 때까지 기다리고, 그 사이에 다른 컴포넌트(예: 로딩 화면)를 보여주게 해주는 도구에요.\n\n`Suspense`를 사용하면, 데이터를 불러오는 동안 보여줄 로딩 화면을 쉽게 설정할 수 있어요.\n\n간단한 예시를 통해 알아볼게요.\n\n```tsx\n<Suspense fallback={<LoadingSpinner />}>\n  <Profile />\n</Suspense>\n```\n\n`<Profile />` 은 실제로 렌더링하려고 하는 UI 부분이에요.\n\n- 만약 이 부분이 렌더링하는 동안 지연(suspend)된다면, `<Suspense>` 경계는 `fallback`으로 전환하여 렌더링하게 됩니다.\n- 이 때, `fallback`에 넣은 `<LoadingSpinner />` 컴포넌트가 잠깐 사용자에게 보여지게 돼요.\n\n<br />\n\n만약 여러 `Suspense` 컴포넌트를 겹쳐 사용한다면, 각기 다른 비동기 작업마다 다른 로딩 화면을 설정할 수도 있어요.\n\n```tsx\n<Suspense fallback={<div>Loading Photo...</div>}>\n  <ProfilePhoto />\n</Suspense>\n<Suspense fallback={<div>Loading Details...</div>}>\n  <ProfileDetails />\n</Suspense>\n```\n\n<br />\n\n또한 여러 개의 자식 요소가 겹쳐 있을 때 발생하는 `Waterfall` 현상을 해결할 수 있어요.\n\n```tsx\nimport React, { Suspense } from \"react\"\n\nconst ProfilePhoto = React.lazy(() => import(\"./ProfilePhoto\"))\nconst ProfileDetails = React.lazy(() => import(\"./ProfileDetails\"))\nconst ProfileTimeline = React.lazy(() => import(\"./ProfileTimeline\"))\n\nfunction Profile() {\n  return (\n    <Suspense fallback={<div>Loading Profile...</div>}>\n      <div>\n        <ProfilePhoto />\n        <ProfileDetails />\n        <ProfileTimeline />\n      </div>\n    </Suspense>\n  )\n}\n```\n\n`Waterfall` 현상은 한 요소가 로드된 후에 다음 요소의 로딩이 시작되는 현상을 말해요. `Suspense`를 사용하면 여러 비동기 요소를 병렬로 로드하여 이 현상을 줄일 수 있습니다.\n\n### Error boundary\n\n`Error boundary`는 자식 컴포넌트 트리에서 발생한 JavaScript 에러를 잡아내고, 이를 로깅하거나 대체 UI를 렌더링하여 애플리케이션이 갑작스럽게 중단되는 것을 방지해주는 도구에요.\n\n즉, 우리가 만든 웹 페이지에서 문제가 생겼을 때 그 문제를 잡아서 애플리케이션이 완전히 멈추지 않게 도와줘요, 이를 이용해 사용자에게 \"문제가 발생했다\"는 메시지를 보여주거나, 다른 화면을 보여줄 수 있어요.\n\n아래는 `Error boundary`를 구현한 코드에요.\n\n```tsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  static getDerivedStateFromError(error) {\n    // 다음 렌더링에서 fallback UI를 보여주기 위한 상태 업데이트\n    return { hasError: true }\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 에러 로깅 서비스에 에러 정보를 기록할 수 있습니다.\n    logErrorToMyService(error, errorInfo)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 에러가 발생했을 때 렌더링할 UI\n      return <h1>오류가 발생했어요.</h1>\n    }\n\n    return this.props.children\n  }\n}\n```\n\n`Error boundary`를 사용하면 컴포넌트 트리의 어느 부분에서든 에러를 처리할 수 있어요. 주로 네트워크 에러, 데이터 처리 에러 등 런타임에 발생할 수 있는 예외를 처리하는 데 사용됩니다.\n\n#### react-error-boundary 사용하기\n\nReact에서 에러 경계를 직접 구현하려면 클래스 컴포넌트를 사용해야 하며 `getDerivedStateFromError`와 `componentDidCatch` 라이프사이클 메서드를 모두 구현해야 해요.\n\n하지만, 함수형 컴포넌트에서는 `Error boundary`를 직접 만들기 어려워요. 그래서 `react-error-boundary`라는 도구를 사용하면 좋은데요, 이 도구를 쓰면 복잡한 클래스 컴포넌트를 직접 만들지 않아도 간단한 컴포넌트와 훅을 통해 `Error boundary`를 사용할 수 있어요.\n\n따라서 그로잉 프로젝트에서는 `react-error-boundary` 라이브러리를 사용하기로 결정했습니다.\n\n### Suspense와 Error boundary를 함께 사용한다면?\n\n`Suspense`와 `Error boundary`를 적용하기 전과 후의 코드를 비교해볼게요.\n\n#### 적용 전\n\n```tsx\nconst Profile = () => {\n  const { data: profile, isError, isLoading } = useQuery([\"profile\"], fetchFoo)\n\n  if (isError) return <div>로딩에 실패했습니다.</div>\n  if (!isLoading) return <div>로딩 중입니다...</div>\n  return <div>{profile?.name}님 안녕하세요!</div>\n}\n```\n\n#### 적용 후\n\n```tsx\nfunction Profile() {\n  const { data: profile } = useQuery([\"profile\"], fetchFoo)\n\n  return <div>{profile?.name}님 안녕하세요!</div>\n}\n```\n\n```jsx\n<ErrorBoundary fallback={<ErrorFallback />}>\n  <Suspense fallback={<LoadingSpinner />}>\n    <Profile />\n  </Suspense>\n</ErrorBoundary>\n```\n\n`Suspense`와 `Error boundary`를 적용한 후, 더이상 `Profile` 컴포넌트는 비동기 데이터 로딩이나 에러 처리를 직접 관리하지 않아도 돼요. 이 두 가지 상황은 각각 `Suspense`와 `Error boundary`에 처리를 위임했어요.\n\n#### 이점은 다음과 같아요.\n\n1. **선언적인 코드**\n\n   `Suspense`와 `Error boundary`를 사용하면, 비동기 로직과 에러 처리 로직을 컴포넌트 외부로 분리할 수 있습니다. 이로 인해 컴포넌트 코드가 더 선언적이고, 읽기 쉬워져요.\n\n1. **향상된 사용자 경험(UX)**\n\n   `Suspense`를 사용하면 비동기 작업이 진행되는 동안 사용자에게 로딩 스피너나 스켈레톤 UI를 손쉽게 보여줄 수 있어요. 또한, `Error boundary`를 통해 예외 상황이 발생했을 때 사용자에게 친절한 에러 메시지를 표시할 수도 있습니다.\n\n<br />\n\n따라서 그로잉 프로젝트에 `Suspense`와 `Error boundary`를 도입하는 리팩토링 전략을 세워보기로 했어요.\n\n## 그로잉 프로젝트의 Suspense, Error boundary 전략\n\n### React query + Suspense + Error boundary 같이 사용하기\n\n그로잉 프로젝트에서는 api 호출 작업을 `react-query`로 하고 있는데요, `react-query`에서는 `Suspense`나 `Error boundary`와 통합할 수 있는 기능을 제공해주고 있어요.\n\n따라서 그로잉에서는 `react-query`와 `Suspense`, `Error boundary`를 함께 사용했습니다.\n\n```tsx\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      //... other options\n      suspense: true,\n      useErrorBoundary: true,\n    },\n    mutations: {\n      //... other options\n      useErrorBoundary: true,\n    },\n  },\n})\n```\n\n먼저, `suspense: true` 와`useErrorBoundary:true` 옵션을 통해 기본적으로 `Suspense`와 `Error boundary`를 사용하도록 했어요.\n\n- `suspense: true`\n  - `react-query`가 데이터를 가져오는 동안 `Suspense`를 통해 컴포넌트를 중단시키고, 데이터가 준비되면 자동으로 컴포넌트를 다시 렌더링해줍니다.\n- `useErrorBoundary:true`\n  - React의 `Error boundary`는 본래 이벤트 핸들러의 에러를 포착하지 않아요.\n    그러나 `react-query`의 `useErrorBoundary` 옵션을 사용하면, API에서 발생한 에러를 `Error boundar`가 캐치할 수 있습니다. 따라서 해당 옵션을 true로 설정했어요.\n\n> 그로잉에 프로젝트에서는 현재 `react-query` v4를 사용하고 있습니다.\n\n### **컴포넌트 계층화**\n\n그로잉에서는 이를 컴포넌트 계층별로 설계했어요.\n\n![](./images/hierarchical.png)\n`Suspense`와 `Error Boundary`를 사용할 영역을 세분화하여 각 컴포넌트의 로딩 및 에러 상태를 적절히 처리하고, 각 에러의 영향 범위를 최소화하고자 했습니다.\n\n### 그로잉의 Suspense 전략\n\n1. **Root Suspense**\n\n   ```tsx\n   // RootSuspense.tsx\n\n   const RootSuspense = ({ children }: PropsWithChildren) => {\n     return <Suspense fallback={<Fallback />}>{children}</Suspense>\n   }\n   ```\n\n   애플리케이션 최상위에서 로딩상태를 처리해 줄 컴포넌트에요. 로딩 상태일 때 `Lottie`로 제작한 `Fallback` 컴포넌트를 보여줍니다.\n\n   ![](./images/root-suspense.png)\n\n2. **Suspense**\n\n   최상위 RootSuspense와 별도로 필요한 곳에서는 `Suspense`를 사용해 로딩 상태를 따로 처리해주었어요. 이때의 fallback은 `react-loading-skeleton` 라이브러리를 사용해 제작한 스켈레톤 ui를 보여줍니다.\n\n   ![](./images/block-suspense.png)\n\n### 그로잉의 ErrorBoundary 전략\n\n1. **Root ErrorBoundary**\n\n   컴포넌트의 최상위에서 하위 `Error boundary`에서 처리하지 못한 에러들을 처리해 주는 `Root Error boundary`에요.\n\n   ```tsx\n   // RootErrorBoundary.tsx\n\n   const RootErrorBoundary = ({ children }: PropsWithChildren) => {\n     const { key } = useLocation()\n\n     return (\n       <ErrorBoundary FallbackComponent={Fallback} resetKeys={[key]}>\n         {children}\n       </ErrorBoundary>\n     )\n   }\n   ```\n\n   ![](./images/root-error.png)\n\n2. **ApiErrorBoundary**\n\n   네트워크 에러로 인해 api 호출을 성공하지 못한 경우를 처리해 줄 `API ErrorBoundary`에요.\n\n   ```tsx\n   // ApiErrorBoundary.tsx\n\n   const ApiErrorBoundary = ({ children }: PropsWithChildren) => {\n     const { reset } = useQueryErrorResetBoundary()\n     const { key } = useLocation()\n\n     return (\n       <ErrorBoundary\n         FallbackComponent={Fallback}\n         onReset={reset}\n         resetKeys={[key]}\n       >\n         {children}\n       </ErrorBoundary>\n     )\n   }\n   ```\n\n   ![](./images/api-error.png)\n\n3. **Block ErrorBoundary**\n\n   지역적으로 `Error boundary`가 필요할 때 사용할 `Block ErrorBoundary` 컴포넌트에요.\n   <br />\n   <br />\n   컴포넌트마다 `Error Boundary`를 설정하면 프로젝트의 복잡성을 증가시키고, 유지 보수를 어렵게 만들 수도 있어요. 따라서, 에러 처리 방법을 표준화하여 코드의 가독성과 유지 보수성을 유지하기 위해 Block Error Boundary를 만들어 사용했어요.\n   <br />\n   <br />\n\n   공통적으로 사용되는 `onReset` 콜백과 `resetKeys`를 이 컴포넌트 안에서 설정함으로써 코드의 중복도 줄일 수 있었어요.\n\n   <br />\n\n   ```tsx\n   // pages/.../BlockErrorBoundary.ts\n\n   import { PropsWithChildren } from \"react\"\n   import { useQueryErrorResetBoundary } from \"@tanstack/react-query\"\n   import { useLocation } from \"react-router-dom\"\n   import { ErrorBoundary, FallbackProps } from \"react-error-boundary\"\n\n   interface Props extends PropsWithChildren {\n     fallbackComponent: React.ComponentType<FallbackProps>\n   }\n\n   const BlockErrorBoundary = ({ children, fallbackComponent }: Props) => {\n     const { reset } = useQueryErrorResetBoundary()\n     const { key } = useLocation()\n\n     return (\n       <ErrorBoundary\n         FallbackComponent={fallbackComponent}\n         onReset={reset}\n         resetKeys={[key]}\n       >\n         {children}\n       </ErrorBoundary>\n     )\n   }\n\n   export default BlockErrorBoundary\n   ```\n\n#### Error boundary의 resetKeys 옵션\n\n`Error boundary`의 `resetKeys` 옵션에 대해 알아볼게요.\n\n한 번 에러가 발생하고 `Error boundary`에 의해 캐치되면, 해당 컴포넌트 트리는 기본적으로 그 상태에서 멈춰 있게 돼요.\n<br />\n즉, 같은 에러가 다시 발생해도 `Error boundary`가 다시 반응하지 않습니다.\n\n<br />\n\n`resetKeys` 옵션을 설정하면 배열 안에 담긴 값이 바뀔 때마다 ErrorBoundary로 잡힌 에러를 초기화해줘요.\n<br />\n\n`resetKeys`옵션에 배열 형태로 값을 지정하면, 이 배열 내의 값이 변경될 때마다 `Error boundary`가 내부 상태를 초기화하고, 자식 컴포넌트 트리를 다시 마운트합니다. 이를 통해 동일한 에러가 반복되어도 `Error boundary`가 다시 반응하게 만들고, 필요한 경우 새로운 에러 처리 또는 대체 UI를 제공할 수 있어요.\n\n> 🤔 **resetKeys에 들어갈 값 선택하기: useLocation의 path vs key**\n>\n> - path를 사용하는 경우:\n>   - 각 페이지(경로) 마다 독립적인 에러 처리가 필요할 때\n> - key를 사용하는 경우:\n>   - key는 라우트 세션의 고유 식별자로, 라우트가 변경될 때마다 새로운 값이 생성됨.\n>   - 라우트가 변경될 때마다 `ErrorBoundary`를 리셋하고자 할 때 사용\n\n그로잉에서는 여러 페이지에서 같은 query data를 사용하는 경우가 많이 있어요.\n<br />\n그래서 페이지를 이동할 때마다 에러를 리셋해 다음 페이지에 영향을 미치지 않게 하기 위해 `resetKeys` 속성에 `useLocation`에서 제공해주는 `key` 값을 사용했습니다.\n\n### 사용 예시\n\n1. 먼저 최상위에서 에러를 처리해줄 `RootErrorBoundary`, `ApiErrorBoundary`, `RootSuspense`로 App컴포넌트를 감싸줍니다.\n\n   ```tsx\n   <RootErrorBoundary>\n     <ApiErrorBoundary>\n       <RootSuspense>\n         <App />\n       </RootSuspense>\n     </ApiErrorBoundary>\n   </RootErrorBoundary>\n   ```\n\n2. 그리고 지역적으로 에러와 로딩 처리가 필요한 곳에서 `Suspense`와 `BlockErrorBoundary`를 사용하면 돼요.\n\n   ```tsx\n   <BlockErrorBoundary fallbackComponent={NoticeList.Error}>\n     <Suspense fallback={<NoticeList.Loading />}>\n       <NoticeList />\n     </Suspense>\n   </BlockErrorBoundary>\n   ```\n\n   ```tsx\n   const NoticeList = () => {\n       ...\n   };\n\n   NoticeList.Loading = () => {\n        return (\n            <S.LoadingContainer>\n            {new Array(20).fill(null).map((_, i) => (\n                <Skeleton height={62} borderRadius={10} key={i} />\n            ))}\n            </S.LoadingContainer>\n        );\n   };\n\n   NoticeList.Error = ({ error, resetErrorBoundary }: FallbackProps) => {\n        return (\n            <BlockErrorFallback.Common\n            error={error}\n            resetErrorBoundary={resetErrorBoundary}\n            />\n        );\n   };\n\n   export default NoticeList;\n   ```\n\n필요한 컴포넌트에 에러 상태와 로딩 상태에 표시할 컴포넌트를 서브 컴포넌트로 (`NoticeList.Loading` `NoticeList.Error`) 등록해 사용했어요.\n\n서브 컴포넌트를 사용하는 방법은 어떤 컴포넌트를 위한 것인지 알기 쉽고, 관련 기능이나 스타일을 찾기 쉽다는 장점이 있는 방식이에요.\n\n## Suspense와 ErrorBoundary를 모든 상황에 쓰는 게 좋을까요?\n\n그렇다면 이 `Suspense`와 `Error boundary`를 비동기 호출이 발생하는 모든 컴포넌트에 적용해야 할까요?\n\n저희는 그렇지 않다고 생각해요. 특정 상황에서는 `Suspense`나 `Error boundary`를 사용하지 않고 다른 방법을 사용하는 것이 더 적합할 수도 있어요.\n\n### Suspense 사용을 피해야 하는 경우\n\n예를 들면 사용자의 특정 액션(버튼 클릭 등)에 의해 트리거되는 로딩 작업의 경우, `Suspense`를 사용하기보다는 로컬 상태 관리를 통해 로딩 상태를 직접 제어하는 것이 더 직관적이에요.\n\n![](./images/not-good-suspense.gif)\n\n### Error boundary가 캐치할 수 없는 에러를 처리해야 하는 경우\n\n`Error boundary`는 React 애플리케이션에서 에러를 효과적으로 관리하는 중요한 도구지만, 모든 종류의 에러를 잡아내지는 못해요.\n\n따라서 특정 상황에서는 `Error boundary`의 한계를 인지하고 다른 에러 처리 방법을 고려해야 할 수도 있어요.\n\n### Error Boundary가 잡아내지 못하는 에러들은 다음과 같아요.\n\n1. **비동기적 코드**\n   - `setTimeout`, `requestAnimationFrame` 같은 비동기 콜백에서 발생한 에러는 `Error boundary`로 잡아낼 수 없어요. 이러한 경우, 콜백이 실행되는 시점에는 이미 컴포넌트의 렌더링 컨텍스트가 종료되었기 때문이죠.\n2. **이벤트 핸들러**\n   - React는 이벤트를 최상위 root element에서 처리하기 때문에, `Error boundary` 내부에서 발생한 이벤트 핸들러의 에러를 포착할 수 없어요. 이는 `Error boundary`의 범위가 이벤트 버블링의 root보다 아래에 위치하기 때문입니다.\n3. **Error Boundary 자체의 에러**\n   - `Error boundary` 컴포넌트 내부에서 발생한 에러는 그 자체로 잡아낼 수 없어요. 이러한 경우, 상위 또는 다른 `Error boundary`를 통해 에러를 관리해야 합니다.\n\n### **Error Boundary의 한계 극복 방법**\n\n1. **try…catch를 활용하기**\n   - 비동기 작업을 `Promise`나 `async/await`과 함께 사용할 때는, 해당 작업의 에러 핸들링 로직을 직접 구현해야 합니다. 예를 들어, `.catch()` 메서드나 `try...catch` 블록을 사용할 수 있죠.\n2. `react-query`**의** `useErrorBoundary`**옵션**\n   - react-query의 useErrorBoundary옵션을 사용하면 비동기 작업에서 발생하는 에러를 캐치해 `Error Boundary`로 처리를 할 수 있어요.\n3. **에러 상태를 전역 상태로 관리하기**\n   - 에러 상황을 전역 상태로 관리하여 적절한 UI를 렌더링하는 방법도 고려할 수 있어요.\n4. **컴포넌트 자체의 에러 처리**\n   - 각 컴포넌트가 자신의 에러를 처리할 수 있도록 만들어, 에러 발생 시 대체 컴포넌트를 렌더링하는 등의 방법으로 문제를 해결할 수 있어요.\n\n### 그로잉에서 사용한 방법\n\n그로잉 프로젝트에서는 비동기 작업 시 발생하는 에러 등 Error boundary가 catch해주지 못하는 에러는 UI를 바꾸는 것보다 사용자에게 간단히 알려주는 게 더 적합한 경우가 많았어요.\n\n따라서 이를 Error boundary가 아닌 toast message를 사용해 처리하도록 했습니다. 이를 통해 에러의 발생을 알리는 동시에 애플리케이션의 나머지 기능은 계속 사용할 수 있게 해주었어요.\n\n```tsx\n  const { mutateAsync: postAnswer } = useAnswerMutation({\n\t\t...\n    options: {\n     useErrorBoundary: false,\n      onSuccess: () => {\n        addToast('답변을 등록했어요.');\n      },\n      onError: () => {\n        addToast('답변 등록에 실패했어요. 이용에 불편을 드려 죄송합니다.');\n      },\n    },\n  });\n\n```\n\n![](./images/growing-error.gif)\n\n## Suspense, Error boundary를 합쳐 사용해도 될까요?\n\n```tsx\n//AsyncBoundary.tsx\n...\n\nexport default function AsyncBoundary({\n  pendingFallback,\n  rejectedFallback,\n  children,\n  ...errorBoundaryProps\n}: Props) {\n  return (\n    <ErrorBoundary fallbackRender={rejectedFallback} {...errorBoundaryProps}>\n      <Suspense fallback={pendingFallback}>{children}</Suspense>\n    </ErrorBoundary>\n  );\n}\n\n```\n\n처음에는 `Suspense`와 `Error boundary`가 함께 사용되는 경우가 많아, 위 코드처럼 둘을 합친 `AsyncBoundary`를 만들어 사용하려 했어요. 하지만 막상 사용해보니 `Error boundary` 하나에 `Suspense`를 여러개를 사용하는 등 1:1로 사용하지 않는 경우들이 꽤 있었어요.\n\n<br />\n\n예를 들어 아래와 같이 로딩 상태는 여러 부분에서 따로 처리하고 싶지만, 에러는 한번에 모아서 처리하고 싶은 상황이 있을 수 있어요. 이런 경우에 모든 `Suspense`에 `Error boundary`가 함께 있는 것은 불필요하기 때문에 `Suspense`와 `Error boundary`를 결합하지 않기로 했어요.\n\n```tsx\nconst Pet = () => {\n  return (\n    <S.Container>\n      <ErrorBoundary FallbackComponent={Pet.Error}>\n        <Suspense fallback={<Ballon.Loading />}>\n          <Ballon />\n        </Suspense>\n\n        <RaisingPet />\n\n        <Suspense fallback={<PetLabel.Loading />}>\n          <PetLabel />\n        </Suspense>\n\n        <Suspense fallback={<PetGauge.Loading />}>\n          <PetGauge />\n        </Suspense>\n      </ErrorBoundary>\n    </S.Container>\n  )\n}\n```\n\n## 결과\n\n### 1. 선언적인 코드 작성이 가능해졌어요.\n\n- **적용 전:** 컴포넌트가 비동기 상태 처리때문에 복잡했어요.\n\n  ```tsx\n  const Emojis = () => {\n    const {\n      data: emojis,\n      isLoading,\n      isError,\n    } = useEmojiDetailData({\n      emojiId: id,\n    })\n\n    if (isLoading) {\n      // 로딩 시\n      return (\n        <S.EmojiGrid>\n          {skeletonArr.map((_, idx) => (\n            <Skeleton key={idx} width={80} height={80} />\n          ))}\n        </S.EmojiGrid>\n      )\n    }\n\n    if (isError) {\n      // 에러 시\n      return (\n        <ErrorFallback>\n          <p>에러가 발생했어요</p>\n        </ErrorFallback>\n      )\n    }\n\n    return (\n      // 응답 성공 시\n      <S.EmojiGrid>\n        {emojis?.map(emoji => (\n          <S.StyledImg\n            key={emoji.id}\n            src={emoji.imageUrl}\n            onClick={() => handleClick(emoji.id)}\n          />\n        ))}\n      </S.EmojiGrid>\n    )\n  }\n  ```\n\n- **적용 후:** 비동기 로직과 에러 처리 로직을 컴포넌트 외부로 분리할 수 있게 됨으로써, 코드가 더 선언적이고 읽기 쉬워졌어요.\n\n  ```tsx\n  <BlockErrorBoundary fallbackComponent={Emojis.Error}>\n    <Suspense fallback={<Emojis.Loading />}>\n      <Emojis />\n    </Suspense>\n  </BlockErrorBoundary>\n  ```\n\n  ```tsx\n  const Emojis = () => {\n    const {\n      data: emojis,\n      isLoading,\n      isError,\n    } = useEmojiDetailData({\n      emojiId: id,\n    })\n\n    return (\n      <S.EmojiGrid>\n        {emojis?.map(emoji => (\n          <S.StyledImg\n            key={emoji.id}\n            src={emoji.imageUrl}\n            onClick={() => handleClick(emoji.id)}\n          />\n        ))}\n      </S.EmojiGrid>\n    )\n  } // 간단해짐\n  ```\n\n### 2. 사용자 경험이 향상됐어요.\n\n- 사용자는 데이터를 가져오는 동안 빈 화면을 보지 않게 되었어요.\n\n  ![](./images/result-suspense.png)\n\n- 그리고 데이터를 받아오는 중에 에러가 발생한 경우 버튼 등을 통해 다시 시도할 수 있고, 어떤 작업을 요청했을 때 에러가 발생하면 toast message를 작업 상황을 받아볼 수 있습니다.\n\n  ![](./images/result-error.png)\n\n### 3. CLS도 향상되었어요.\n\n`CLS(Cumulative Layout Shift)`도 향상되었는지 확인해볼게요.\n\n> - CLS 기준 점수\n>   <br />- 0.1 이하인 경우 좋음\n>   <br />- 0.25 이하인 경우 보통\n>   <br />- 그 외에는 개선이 필요한 나쁜 점수\n\n데이터가 들어갈 자리에 Skeleton이 미리 차지하도록 했기 때문에 `CLS` 지표가 개선된 것을 볼 수 있어요.\n\n![](./images/result-cls.png)\n\n### 마치며\n\n이를 통해 그로잉 프로젝트는 개발자 경험(DX)과 사용자 경험(UX) 모두 높일 수 있었어요.\n\n<br />\n특히 이전에 만들었던 MSW Toolbar를 활용하여 쉽게 테스트해가며 작업할 수 있었습니다.\n\n![](./images/result-ux.gif)\n\n> 🤔 그로잉 팀의 MSW Toolbar 제작기가 궁금하다면? ⇒ [그로잉 팀의 MSW Toolbar 제작기](https://teamgrowing.github.io/team-blog/msw-toolbar)\n\n<br />\n\n앞으로도 적절한 비동기 처리로 사용자에게 더 나은 서비스를 제공하는 그로잉 팀이 되어볼게요. 감사합니다 :)\n"},{"excerpt":"툴바를 만들자! 저희 그로잉팀은 런타임에서 여러 기능들의 성공과 실패의 조합에 따라 테스트를 할 수 있는 방식이 필요했고, 이를 MSW Toolbar를 만들어 해결했어요. 이번 글에서는 MSW Toolbar 제작 과정을 소개할게요. 정의된 핸들러 리스트 받아오기 툴바 구현을 위해 먼저 정의해 둔 핸들러 리스트 정보들을 가져올 수 있는 지가 가장 중요했어요…","fields":{"slug":"/msw-toolbar/"},"frontmatter":{"date":"February 25, 2024","title":"API 요청 시뮬레이션을 간편하게: 그로잉 팀의 MSW Toolbar 도입기","tags":["growing","msw","mocking"]},"rawMarkdownBody":"\n## 툴바를 만들자!\n\n저희 그로잉팀은 런타임에서 여러 기능들의 성공과 실패의 조합에 따라 테스트를 할 수 있는 방식이 필요했고, 이를 MSW Toolbar를 만들어 해결했어요.\n\n이번 글에서는 MSW Toolbar 제작 과정을 소개할게요.\n\n<div align='center'>\n    <img src='msw.gif' width='300px'  />\n</div>\n\n### 정의된 핸들러 리스트 받아오기\n\n툴바 구현을 위해 먼저 정의해 둔 핸들러 리스트 정보들을 가져올 수 있는 지가 가장 중요했어요. 따라서 해당 정보를 받아올 수 있는지 확인하는 작업을 먼저 진행했어요.\n\n```tsx\n// App.ts\nimport { handlers } from \"mocks/handlers\"\n\n// 각 핸들러의 경로와 메소드 정보를 콘솔에 출력\nhandlers.forEach(handler => {\n  const { path, method } = handler.info // 핸들러의 정보에서 경로와 메소드 추출\n  console.log({ path, method })\n})\n```\n\n다행히도 MSW 핸들러에서 제공하는 정보를 활용하여, 간단한 코드 몇 줄로 원하는 핸들러 정보를 추출할 수 있었어요.\n\n![](handler-list-image.png)\n이렇게 콘솔에 출력된 정보를 바탕으로, 핸들러 정보를 관리하는 클래스나 객체를 구성하여 필요할 때마다 활용하면 될 것 같네요!\n\n### UI\n\n툴바의 UI는 피그마를 사용하여 디자인했습니다. 툴바에 포함될 주요 기능은 다음과 같아요.\n\n1. **API 경로 검색**: 사용자가 특정 API 경로를 검색하여 해당하는 핸들러를 찾을 수 있습니다.\n2. **상태 코드 변경**: 성공 또는 에러 상태 코드를 동적으로 변경할 수 있어, 다양한 응답 시나리오를 시뮬레이션할 수 있습니다.\n3. **응답 지연 설정**: API 응답의 지연 시간을 설정하여 네트워크 지연 테스트를 할 수 있습니다.\n\n![](ui-image.png)\n\n### **핸들러 동적 변경 고려사항**\n\n상태 코드나 응답 지연 시간을 변경하려면, 기존의 핸들러 코드를 동적으로 조절할 필요가 있었어요. 예를 들어, 성공 응답과 에러 응답을 다루는 두 가지 핸들러가 있다고 가정해 보겠습니다.\n\n```tsx\n// mocks/user/getUserHandler.ts\ntype Params = {\n  userId: string;\n};\n\nconst data: UserDto = {\n\tid: '1',\n\tnickName: '곰곰곰',\n\tbirthDay: '2000-01-01',\n\tanniversaryDay: '2023-12-16',\n};\n\n// 성공 응답 핸들러\nexport const getUserSuccessHandler = () => {\n\thttp.get<Params, null, UserDto, '/user/:userId'>(\n    '/user/:userId',\n    async () => {\n\t\t\tawait delay(1000); // 1초 지연\n\n      return HttpResponse.json(data, {\n\t      status: 200,\n\t      statusText: '요청에 상공했습니다.',\n\t\t});\n  });\n}\n\n// 실패 응답 핸들러\nexport const getUserErrorHandler = () => {\n\thttp.get<Params, null, null, '/user/:userId'>(\n    '/user/:userId',\n    async () => {\n\t\t\tawait delay(500); // 0.5초 지연\n\n      return HttpResponse.json(null, {\n\t      status: 400,\n\t      statusText: '요청에 실패했습니다.',\n    }),\n  });\n}\n```\n\n세 부분에서 변경이 일어나는 것을 알 수 있어요.\n\n1. **응답 타입**: 성공과 실패 응답의 타입이 다를 수 있습니다.\n2. **지연 시간**: `delay` 함수의 인자를 통해 응답 지연 시간을 설정합니다.\n3. **응답 데이터**: `HttpResponse.json` 메소드의 인자로 전달되는 데이터입니다.\n\n따라서 이 요소들을 런타임에 동적으로 바꿔줄 수 있어야 했어요. 이를 하드코딩이 아닌 변수로 지정해두고 동적으로 바꿔주면 될 것 같아요.\n\n### 해당하는 URL에 맞는 핸들러 찾는 법\n\n그렇다면 검색한 API URL에 맞는 핸들러는 어떻게 찾을 수 있을까요?\n\n같은 URL에 대해 다른 HTTP 메소드(GET, POST, DELETE 등)를 사용하는 경우가 많기 때문에, 단순히 URL만으로 핸들러를 찾는 것은 충분하지 않았아요.\n\n이를 해결하기 위해 핸들러 정보를 저장할 때 URL 경로와 HTTP 메소드의 조합을 고유한 식별자로 사용하기로 결정했어요.\n\n```tsx\ninterface HandlerInfoList {\n  [path: string]: {\n    [method: string]: HandlerInfo\n  }\n}\n```\n\n![](url-search-image.png)\n\n### HandlerInfoManager 구현과 활용\n\n핸들러들을 저장하고 꺼내오고 delay 변수값들을 변경시켜주는 작업을 저희 그로잉 팀은 HandlerInfoManager 클래스를 제작하여 해결하였어요.\n\n```tsx\nimport { handlers } from \"mocks/handlers\"\n\nconst DEFAULT_STATUS = 200\nconst DEFAULT_DELAY = 1000\n\ntype StatusType = 200 | 400\n\ninterface HandlerInfo {\n  status: StatusType\n  delayTime: number\n}\n\ninterface HandlerInfoList {\n  [path: string]: {\n    [method: string]: HandlerInfo\n  }\n}\n\ninterface HandlerInfoParams {\n  path: string\n  method: string\n  code: StatusType\n  time: number\n}\n\nclass HandlerInfoManager {\n  private handlerInfos: HandlerInfoList = {}\n\n  // 핸들러 정보 초기화\n  public initHandlerInfo(): void {\n    handlers.forEach(handler => {\n      const { path, method } = handler.info\n      this.setHandlerInfo({\n        path: path.toString(),\n        method: method.toString(),\n        code: 200, // 기본 상태 코드\n        time: 1000, // 기본 지연 시간\n      })\n    })\n  }\n\n  // 핸들러 정보 설정\n  public setHandlerInfo({ path, method, code, time }: HandlerInfoParams): void {\n    if (!this.handlerInfos[path]) {\n      this.handlerInfos[path] = {}\n    }\n    this.handlerInfos[path][method] = { status: code, delayTime: time }\n  }\n\n  // 핸들러 리스트 조회\n  public getHandlerInfos(): HandlerInfoList {\n    return this.handlerInfos\n  }\n\n  // 특정 핸들러 정보 조회\n  public getHandlerInfo(path: string, method: string): HandlerInfo | undefined {\n    return this.handlerInfos[path]?.[method]\n  }\n}\n\nexport const handlerInfoManager = new HandlerInfoManager()\n```\n\n이렇게 `HandlerInfoManager`를 사용하면 핸들러의 상태 코드와 지연 시간을 런타임에 변경할 수 있으며, 툴바 UI에서 사용자의 입력에 따라 이러한 변경을 적용할 수 있습니다.\n\n### 사용 예시\n\n사용 예시는 다음과 같아요.\n\n```tsx\nimport { handlerInfoManager } from \"mocks/HandlerInfoManager\"\nimport { CoupleDto } from \"models/couple\"\nimport { delay, http, HttpResponse } from \"msw\"\n\ninterface Params {\n  coupleId: string\n}\n\nconst data: CoupleDto = {\n  coupleId: \"1\",\n  myName: \"연주\",\n  partnerName: \"민지\",\n  dayCount: 10,\n  petId: null,\n}\n\nexport const getCoupleHandler = http.get<Params, {}, CoupleDto | null>(\n  \"/couples/:coupleId\",\n  async () => {\n    const responseList = {\n      200: HttpResponse.json(data, {\n        status: 200,\n        statusText: \"success\",\n      }),\n      400: HttpResponse.json(null, {\n        status: 400,\n        statusText: \"fail\",\n      }),\n    }\n\n    const handler = handlerInfoManager.getHandlerInfo(\n      \"/couples/:coupleId\",\n      \"GET\"\n    )\n\n    const status = handler?.status || 200\n    const delayTime = handler?.delayTime || 0\n\n    await delay(delayTime)\n    return responseList[status]\n  }\n)\n```\n\n```tsx\nconst handleClick = (path: string, method: string) => {\n  handlerInfoManager.setHandlerInfo({ path, method, code: 400, time: 3000 })\n}\n```\n\n### 추상화를 해보자\n\n모든 API 핸들러에서 반복적으로 나타나는 패턴들은 무엇이 있을까요?\n\n코드를 분석해 본 결과 다음 코드가 반복해서 작성되어야 했어요. 이를 추상화하여 코드 중복을 줄여볼게요.\n\n```tsx\nconst handler = handlerInfoManager.getHandlerInfo(\"/couples/:coupleId\", \"GET\")\n\nconst status = handler?.status || 200\nconst delayTime = handler?.delayTime || 0\n\nawait delay(delayTime)\nreturn responseList[status]\n```\n\n```tsx\nimport { handlerInfoManager } from \"mocks/HandlerInfoManager\"\nimport { delay, http } from \"msw\"\n\n// 상태 코드별 응답 데이터를 매핑하는 객체 타입을 정의합니다.\ntype ResponseData<TResponse> = {\n  [key: number]: TResponse | null\n}\n\n// API 요청 처리 함수 타입을 정의합니다.\ntype RequestHandler<TParams, TResponse> = (\n  params: TParams\n) => ResponseData<TResponse>\n\n// 범용 API 핸들러 생성 함수를 정의합니다.\nexport const createApiHandler = <TParams, TResponse>(\n  path: string,\n  method: keyof typeof http,\n  handleRequest: RequestHandler<TParams, TResponse>\n) => {\n  return http[method](path, async req => {\n    const params = req.params as TParams\n    const handler = handlerInfoManager.getHandlerInfo(path, method)\n    const delayTime = handler?.delayTime || 0\n    const responseStatus = handler?.status || 200\n\n    await delay(delayTime)\n\n    const responseData = handleRequest(params)\n    return responseData[responseStatus]\n  })\n}\n```\n\n이 추상화를 통해 아래처럼 간편하게 개별 핸들러들을 구현할 수 있게 되었어요. 각 API 핸들러마다 상태 코드와 지연 시간을 처리하는 로직을 반복해서 작성할 필요가 없어진거죠.\n\n```tsx\n// 사용 예시: 커플 정보 조회 API 핸들러\ninterface Params {\n  coupleId: string\n}\n\nconst data: CoupleDto = {\n  coupleId: \"1\",\n  myName: \"연주\",\n  partnerName: \"민지\",\n  dayCount: 10,\n  petId: \"1\",\n}\n\nexport const getCoupleHandler = createApiHandler<Params, CoupleDto | null>(\n  \"/couples/:coupleId\",\n  \"get\",\n  () => ({\n    // 여기서는 단순화를 위해 바로 데이터를 반환하지만,\n    // 실제로는 params를 기반으로 데이터를 조회하거나 처리할 수 있습니다.\n    200: data, // 성공 응답\n    400: null, // 실패 응답\n  })\n)\n```\n\n## 그러나,,\n\n처음에 생각한 기능들 외에 추가로 필요한 기능들이 있었어요. 처음에는 Path Parameter만 필요했었지만 Query Parameter가 필요한 경우도 있었어요.\n\n> Parameter type\n>\n> 1. Query parameters: `?a=1&b=2`;\n> 2. Path parameters: `GET /user/:id`, where `id` is a path parameter.\n\n그리고 API 호출 성공 후에 로직을 처리할 콜백 함수가 필요했어요. DELETE 요청 후에 기존 data를 삭제하거나, PATCH 후에 수정하는 코드가 필요했기 때문이에요.\n\n이러한 추가 요구사항을 충족하기 위해 다음과 같이 `createApiHandler` 함수를 확장했어요.\n\n```tsx\n// ApiHandlerCreator.ts\nimport { DefaultBodyType, PathParams, delay, http, HttpResponse, StrictRequest } from 'msw';\nimport { handlerInfoManager } from './HandlerInfoManager';\n\n// 응답 데이터 타입 정의: 상태 코드별로 응답 데이터를 매핑\ntype ResponseData<TResponse> = {\n  [status: number]: NullableResponse<TResponse>;\n};\n\n// 요청 처리 핸들러 타입 정의: 경로 및 요청 매개변수를 받아 응답 데이터를 반환\ntype RequestHandler<TParams, TRequest, TResponse> = (\n  params: TParams,\n  request: TRequest\n) => ResponseData<TResponse>;\n\n// 요청 처리 후 실행할 콜백 함수 타입 정의\ntype AfterRequest<TParams, TRequest> = (\n  params: TParams,\n  request: TRequest\n) => void;\n\n// 범용 API 핸들러 생성 함수\nexport const createApiHandler = <\n  TParams extends PathParams,\n  TRequest extends DefaultBodyType,\n  TResponse extends DefaultBodyType\n>(\n  path: string;\n  method: keyof typeof http;\n  requestHandler: RequestHandler<TParams, StrictRequest<TRequest>, TResponse>;\n  onSuccess?: AfterRequest<TParams, StrictRequest<TRequest>>;\n  ) => {\n  return http[method]<TParams, TRequest, TResponse>(\n    path,\n    async ({ params, request }) => {\n      // 요청 처리 함수를 호출하여 응답 데이터를 가져옴\n      const responseData = requestHandler(params, request);\n\n      // 핸들러 정보(응답 지연 시간 및 상태 코드) 조회\n      const handlerInfo = handlerInfoManager.getHandlerInfo(path, method);\n      const delayTime = handlerInfo?.delayTime || 0;\n      const responseStatus = handlerInfo?.status || 200;\n\n      // 응답 지연 시간 적용\n      await delay(delayTime);\n\n      // 성공적인 요청 처리 후 콜백 함수 실행\n      if (responseStatus !== 400) {\n        onSuccess?.(params, request);\n      }\n\n      // JSON 형태로 응답 반환\n      return HttpResponse.json(responseData[responseStatus], {\n        status: responseStatus,\n      });\n    }\n  );\n};\n```\n\n### 리팩토링: 파라미터 객체화\n\n함수의 매개변수가 많아짐에 따라 가독성과 사용성 문제가 발생했어요. 몇번째 파라미터에 어떤 값을 넣어줘야 할지 시각적으로 알아보기 어려웠기 때문이에요.\n\n이를 해결하기 위해 \"객체 비구조화 할당(destructuring)\" 기법을 적용하여 함수 매개변수를 객체화했습니다. 이 접근 방식을 통해 함수 호출 시 매개변수의 순서에 덜 의존할 수 있게 되었고, 코드의 가독성을 향상시킬 수 있었어요.\n\n```tsx\n// 변경전\nexport const deleteOurChatHandler = createApiHandler<\n  ChatDeleteParams,\n  {},\n  null\n>(\n  \"/couples/:coupleId/chattings/:chattingId/delete-ours\",\n  \"delete\",\n  () => ({\n    200: null,\n    400: null,\n  }),\n  ({ chattingId }) => {\n    chatData = chatData.filter(chat => chat.parentChatting.id !== chattingId)\n  }\n)\n```\n\n```tsx\n// 변경후\nexport const deleteOurChatHandler = createApiHandler<\n  ChatDeleteParams,\n  {},\n  null\n>({\n  path: \"/couples/:coupleId/chattings/:chattingId/delete-ours\",\n  method: \"delete\",\n  requestHandler: () => ({\n    200: null,\n    400: null,\n  }),\n  onSuccess: ({ chattingId }) => {\n    chatData = chatData.filter(chat => chat.parentChatting.id !== chattingId)\n  },\n})\n```\n\n### MSW 툴바 컴포넌트 제작하기\n\n이제 툴바 컴포넌트를 제작해 볼게요.\n\n<img src='selector-image.png' width='300px' />\n\n```tsx\n//MSWToolbar.tsx\nimport ...\n\nfunction MSWToolbar() {\n  const queryClient = useQueryClient();\n  const [open, setOpen] = useState(false)\n  const [items, setItems] = useState(\n    Object.entries(handlerInfoManager.getHandlerInfos())\n  )\n  const stagedValue = useRef<{\n    [path: string]: {\n      [method: string]: HandlerInfo\n    }\n  }>({})\n\n\n  const inputChangeHandler = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { value } = e.target\n    setItems(\n      Object.entries(handlerInfoManager.getHandlerInfos()).filter(([path]) =>\n        path.includes(value)\n      )\n    )\n  }\n\n  const clickApplyBtnHandler = () => {\n    Object.keys(stagedValue.current).forEach(path => {\n      Object.keys(stagedValue.current[path]).forEach(method => {\n        const { status, delayTime } = stagedValue.current[path][method]\n        handlerInfoManager.setHandlerInfo({\n          path,\n          method,\n          code: status,\n          time: delayTime,\n        })\n      })\n    })\n    stagedValue.current = {};\n    queryClient.invalidateQueries();\n    setOpen(false)\n  }\n\n  return (\n    <>\n      {!open && (\n        <S.ToolbarButton onClick={() => setOpen(true)}>MSW</S.ToolbarButton>\n      )}\n      {open && (\n        <ToolbarBottomSheet open={open} setOpen={setOpen}>\n          <S.SearchBar>\n            <Icon icon=\"IconSearch\" />\n            <S.Input onChange={inputChangeHandler} />\n          </S.SearchBar>\n          {items.length === 0 && (\n            <S.MessageBox>검색 결과가 없어요!</S.MessageBox>\n          )}\n          {items.length > 0 && (\n            <S.ItemsContainer className=\"hidden-scrollbar\">\n              {items.flatMap(([path, methods]) =>\n                Object.entries(methods).map(\n                  ([method, { delayTime, status }]) => (\n                    <ToolbarItem\n                      key={`${path}-${method}`}\n                      method={method}\n                      path={path}\n                      delayTime={delayTime}\n                      status={status}\n                      onChange={(time, code) => {\n                        stagedValue.current[path] =\n                          stagedValue.current[path] ?? {}\n                        stagedValue.current[path][method] = {\n                          status: code,\n                          delayTime: time,\n                        }\n                      }}\n                    />\n                  )\n                )\n              )}\n            </S.ItemsContainer>\n          )}\n          {items.length > 0 && (\n            <S.ButtonArea>\n              <S.Button onClick={clickApplyBtnHandler}>적용하기</S.Button>\n            </S.ButtonArea>\n          )}\n        </ToolbarBottomSheet>\n      )}\n    </>\n  )\n}\n\nexport default MSWToolbar;\n```\n\n툴바 컴포넌트의 전체 코드와 툴바의 옵션 선택 부분입니다. 코드의 동작 과정을 자세히 살펴볼게요.\n\n- `handlerInfoManager.getHandlerInfos()` 를 사용해 handler의 path와 method를 받아오고 있어요.\n- `inputChangeHandler` 는 검색 창의 input value가 변경되었을 때 호출되는 함수에요. 텍스트를 입력할 때마다 입력된 경로가 포함되는 요소들을 보여줍니다.\n- 각 핸들러에 대응되는 드롭다운 메뉴에서 옵션을 선택하면, 옵션을 stagedValue 변수에 저장합니다.\n- 적용하기 버튼을 누르면, `clickApplyBtnHandler` 가 실행되어 stagedValue에 저장된 옵션들(delay와 status code)이 실제 핸들러에 적용됩니다. 현재 그로잉 프로젝트에서는 react-query를 사용하고 있어서 옵션들을 적용한 후 바로 데이터를 refetch하도록 만들기 위해 마지막으로 `queryClient.invalidateQueries()` 를 실행해주고 있어요.\n- real은 현실적인 응답 시간 정도를 지연해주는 옵션입니다. infinite는 응답을 무한하게 delay 시켜주는 옵션입니다. 이는 로딩 상태가 잘 표시되는 지 등을 확인할 때 유용하게 사용할 수 있어요.\n\n#### 코드에서 한 가지 생각해볼 점이 있었어요.\n\n`const stagedValue = useRef<{[key: string]: SetHandlerParams;}>({});` 부분에서 왜 useRef 훅을 사용했을까요?\n\nstagedValue를 useRef없이 사용하면, 검색을 할 때마다 MSWToolbar 컴포넌트가 재실행 되어 stagedValue가 빈 객체로 초기화됩니다. 이를 방지하고자 useState 훅을 사용하면, stagedValue가 변경 될 때마다 리렌더링이 발생해요.\n\n그래서 컴포넌트가 재실행 되더라도 stagedValue값을 유지하면서, stagedValue가 변경되더라도 리렌더링이 일어나지 않게 하기 위해 useRef hook을 사용했어요.\n\n### 툴바는 리액트 돔 트리에서 어디에 위치해야 할까?\n\n```tsx\nconst root = ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement)\n\nenableMocking().then(() => {\n  root.render(\n    <React.StrictMode>\n      <BrowserRouter>\n        <QueryClientProvider client={queryClient}>\n          <ReactQueryDevtools initialIsOpen={false} />\n          <GlobalStyle />\n          <ThemeProvider theme={myTheme}>\n            {process.env.NODE_ENV === \"development\" && <MSWToolbar />}\n            <AsyncBoundary\n              pendingFallback={<FullScreenLoading />}\n              rejectedFallback={({ error, resetErrorBoundary }) => (\n                <FullScreenError\n                  error={error}\n                  resetErrorBoundary={resetErrorBoundary}\n                />\n              )}\n            >\n              <App />\n            </AsyncBoundary>\n          </ThemeProvider>\n        </QueryClientProvider>\n      </BrowserRouter>\n    </React.StrictMode>\n  )\n})\n```\n\n**다음은 MSWToolbar 컴포넌트의 위치를 선택할 때 고려한 내용들이에요.**\n\n1. MSWToolbar는 dev모드에서만 뜨도록 해야 합니다.\n2. MSWToolbar는 런타임에 영향을 주지 않아야 합니다.\n3. MSWToolbar에서 styled-component의 theme을 이용하고 있어 ThemeProvider 안에 들어가야 합니다.\n4. react query로 관리되고 있는 서버 데이터의 invalidate해줄 수 있어야 하므로 QueryClientProvider 안에 들어가야 합니다.\n\n1번을 위해 NODE_ENV에 따라 Toolbar를 표시해 주었고 2, 3번을 고려해 AsyncBoundary밖이면서 ThemeProvider와 QueryClientProvider의 안에 위치 시켰어요.\n\nMSWToolbar를 이용해 의도적으로 error 상황을 테스트할 때, 그로잉 프로젝트에서 AsyncBoundary와 함께 사용하고 있는 FullScreenError가 뜰 수 있어요. 이때, MSWToolbar는 런타임에서 발생하는 에러 범위 밖에서 상태코드를 200으로 바꿔줄 수 있어야 하기 때문에 AsyncBoundary밖에 위치시켜두었어요.\n\n## 결론\n\n이 과정을 통해 MSW와 MSW를 활용한 Toolbar 도입에 성공할 수 있었어요.\n\nMSW를 통한 API 모킹은 API 경로를 기반으로 이루어지므로, 각 요청을 명확하게 식별하고 관리할 수 있었어요.\n\nMSW Toolbar는 네트워크 요청의 시뮬레이션 과정을 간소화해주는데 큰 도움을 주었어요. 기존에는 네트워크 상태를 모니터링하고 조정하기 위해 크롬의 개발자 도구에 의존했지만, 이제는 Toolbar를 통해 직접적으로 응답 시간을 조절하거나 특정 API 요청에서 에러 상태를 유발하는 등의 작업을 쉽게 처리할 수 있게 되었어요. 이에 따라 다양한 네트워크 환경과 에러 상황을 빠르게 시뮬레이션하고 대응할 수 있을 것으로 기대하고 있어요.\n\n이를 통해 개발 과정에서의 시행착오를 줄이고, 개발 효율성을 높여가며, 최종적으로 사용자에게 더 나은 서비스를 제공하는 그로잉 팀이 되어볼게요. 감사합니다 :)\n"},{"excerpt":"mocking에 대해 알아보자 1. mocking 이란? 모킹은 특정 객체의 실제 구현 대신 가짜 객체를 사용해서 그 객체의 행동을 모방하는 프로세스입니다. 이러한 가짜 객체를 'mock 객체'라고 해요. Mock 객체는 우리의 서비스가 의존하고 있는 외부 시스템이나 복잡한 로직 없이도 동작할 수 있도록 해줍니다. 예를 들어, 서비스에서 사용하고 있는 실…","fields":{"slug":"/msw/"},"frontmatter":{"date":"February 24, 2024","title":"MSW로 mocking을 해보자 ","tags":["growing","msw","mocking"]},"rawMarkdownBody":"\n## mocking에 대해 알아보자\n\n### **1. mocking 이란?**\n\n**모킹**은 특정 객체의 실제 구현 대신 가짜 객체를 사용해서 그 객체의 행동을 모방하는 프로세스입니다. 이러한 가짜 객체를 'mock 객체'라고 해요. Mock 객체는 우리의 서비스가 의존하고 있는 외부 시스템이나 복잡한 로직 없이도 동작할 수 있도록 해줍니다. 예를 들어, 서비스에서 사용하고 있는 실제 DB를 거치지 않고 가짜 데이터를 사용하는 것입니다.\n\n### **2. mocking의 이점**\n\n그럼 어떤 이점이 있길래 mocking을 하는 걸까요? mocking의 장점을 3가지로 정리해볼 수 있어요.\n\n1. **외부 서비스나 리소스에 대한 의존성 제거**\n\n   → 외부 API나 데이터베이스와 같은 외부 서비스, 네트워크 지연 등에 영향을 받지 않고 테스트를 수행할 수 있습니다.\n\n2. **어려운 조건과 상황의 시뮬레이션**\n\n   → 네트워크 오류나 데이터베이스 연결 오류 등과 같은 예외 상황이나 희귀한 상황을 임의로 재현해서 특정 상황에서 애플리케이션이 어떻게 동작하는 지 테스트할 수 있습니다.\n\n3. **비용 절감**\n\n   → 테스트를 할 때 실제 서버를 이용하면 서버 비용이 부담이 될 수 있어요. 하지만 mocking을 통해 수행하면 실제 리소스를 사용하지 않으므로 테스트 비용을 절감할 수 있습니다.\n\n### **3. 우리가 모킹을 결정한 이유**\n\n그렇다면 그로잉 프로젝트에서 서버 데이터를 모킹 하기로 한 이유는 무엇일까요?\n\n저희는 비용 문제로 인해 서버를 계속 켜놓을 수 없었어요. 그리고 각 기능별로 에러와 로딩 상황에 대한 UI를 수정할 예정이라 이런 상황들을 빠르게 재현하고 적절히 처리하는데 mocking의 도움을 받으면 좋겠다는 생각을 했어요. 마지막으로, 후에 테스트 코드를 작성할 때 mocking 데이터를 재활용할 수 있다는 점도 저희의 결정에 영향을 줬습니다.\n\n## mocking 도구 비교 분석\n\n### 다른 라이브러리 소개\n\n- **Nock**\n  - Node.js 환경에서 HTTP 요청을 mocking하고, 테스팅할 수 있는 강력한 라이브러리에요. 주로 서버 사이드에서 API 호출을 가로채고 대체 응답을 제공하는 데 사용됩니다.\n- **Mirage JS**\n  - 백엔드 없이도 클라이언트 사이드에서 API를 모의할 수 있게 해주는 라이브러리에요. Mirage는 자체 ORM과 라우터를 제공하여 실제 백엔드 서버를 흉내낼 수 있습니다.\n- **JSON Server**\n  - 간단한 REST API를 빠르게 프로토타이핑하고자 할 때 유용한 툴로, JSON 파일을 데이터베이스로 사용하여 실제 서버처럼 작동하는 가짜 API 서버를 생성할 수 있습니다.\n\n### 라이브러리 비교\n\n1. **API support**\n\n   |               | MSW | Nock | Mirage                            | JSON server |\n   | ------------- | --- | ---- | --------------------------------- | ----------- |\n   | REST API      | ✅  | ✅   | ✅                                | ✅          |\n   | GraphQL API   | ✅  | ⛔   | 부분 지원(써드파티 애드온을 통해) | ⛔          |\n   | WebSocket API | ⛔  | ⛔   | ⛔                                | ⛔          |\n\n2. **Supported environment**\n\n   |         | MSW | Nock | Mirage                                                                             | JSON server                                  |\n   | ------- | --- | ---- | ---------------------------------------------------------------------------------- | -------------------------------------------- |\n   | Node.js | ✅  | ✅   | 부분 지원(주로 프런트엔드 위주, Node.js는 Mirage의 서버 사이드 렌더링 지원을 통해) | ✅                                           |\n   | Browser | ✅  | ⛔   | ✅                                                                                 | ⛔ (프록시 서버를 통해 간접적으로 사용 가능) |\n\n### **MSW만의 특징**\n\nMSW(Mock Service Worker)를 다른 mocking 도구들과 비교하여 채택한 주요 이유는 다음과 같아요.\n\n- **실제 네트워크 환경과의 유사성**\n  - MSW는 서비스 워커를 사용하여 실제 네트워크 요청을 가로채고 모의 응답을 제공해요. 이 접근 방식은 개발자가 실제 백엔드와 통신하는 것처럼 코드를 작성할 수 있게 하며, 나중에 실제 API로의 전환을 매끄럽게 해줘요. 다른 도구들이 라이브러리 레벨에서 모의를 제공하는 것과는 대조적으로, MSW는 네트워크 레벨에서 작동하므로 개발 경험이 더욱 실제 서버와 유시헤요.\n- **광범위한 테스트 및 개발 환경 지원**\n  - MSW는 브라우저 뿐만 아니라 Node.js 환경에서도 작동해요. 또한 Jest와 같은 단위 테스트 프레임워크뿐만 아니라 Cypress, Storybook과 같은 통합 테스트 및 UI 컴포넌트 테스트 환경에서도 사용할 수 있어요. 이는 하나의 모의 설정을 통해 여러 테스팅 환경과 개발 환경에서 일관된 API mocking을 가능하게 도와줍니다.\n\n## 초기 세팅을 해보아요.\n\n우선 사용자 데이터를 불러오는 간단한 API를 MSW를 사용해 연동해볼게요.\n\n### **1. 핸들러 작성하기**\n\n먼저, API 요청을 가로챌 핸들러를 작성해야 합니다.\n\n```tsx\n// handlers.ts\nimport { http, HttpResponse, delay } from \"msw\"\n\nexport const handlers = [\n  http.get<GetUserParams, null, UserDto, \"/user/:userId\">(\n    \"/user/:userId\",\n    async ({ params }) => {\n      const { userId } = params\n\n      await delay(1000)\n\n      return HttpResponse.json({\n        id: userId,\n        nickName: \"곰곰곰\",\n        birthDay: \"2000-01-01\",\n        anniversaryDay: \"2023-12-16\",\n      })\n    }\n  ),\n]\n```\n\n> HttpResponse 대신 new Response(..) 를 사용할 수도 있지만, HttpResponse가 1) json(),formData() 같은 유용한 메서드를 지원해주고 2) set-cookie를 설정할 수도 있어서 HttpResponse를 사용했어요.\n\n### **2. 브라우저 환경과 통합하기**\n\nMSW를 웹 애플리케이션과 통합하기 위해서는 몇 가지 단계를 더 거쳐야 해요.\n\n1. **Worker script 설치**\n\n   아래 명령어를 실행합니다.\n\n   ```powershell\n   npx msw init ./public --save\n   ```\n\n2. **Worker 설정**\n\n   MSW Worker를 설정하고 핸들러를 등록합니다.\n\n   ```tsx\n   // browser.ts\n   import { setupWorker } from \"msw/browser\"\n   import { handlers } from \"./handlers\"\n\n   export const worker = setupWorker(...handlers)\n   ```\n\n3. **Worker 등록 및 실행**\n\n   개발 환경에서만 MSW를 활성화하기 위해 조건을 설정하고, 애플리케이션 실행 전에 Worker를 등록합니다.\n\n   ```tsx\n   // msw.ts\n   const enableMocking = async () => {\n     if (process.env.NODE_ENV !== \"development\") {\n       return\n     }\n\n     const { worker } = await import(\"./mocks/browser\")\n\n     return worker.start()\n   }\n\n   // index.tsx\n   const root = ReactDOM.createRoot(document.getElementById(\"root\"))\n   enableMocking().then(() => {\n     root\n       .render\n       // 애플리케이션 컴포넌트\n       ()\n   })\n   ```\n\n### **3. 콘솔에서 확인하기**\n\n애플리케이션을 실행한 후, 개발자 도구의 콘솔에서 MSW가 정상적으로 작동하는지 확인합니다.\n\n![](console-1-image.png)\n\n잘 작동하네요! 😮😮\n\n### **4. Mocking하지 않은 API 처리하기**\n\n그런데 콘솔에는 많은 경고가 존재하고 있었어요.\n\n![](console-2-image.png)\n\n이를 알아본 결과, MSW는 정의되지 않은 API 요청을 모두 캐치해 경고를 출력한다고 해요.\n\n<div align='center'>\n    <img src='console-3-image.png' width='300px' />\n</div>\n\n따라서 onUnhandledRequest 옵션을 bypass로 설정하여 정의되지 않은 API 요청은 무시하도록 설정했어요.\n\n```tsx\nworker.start({ onUnhandledRequest: \"bypass\" })\n```\n\n## 폴더 구조를 잡아봅시다.\n\n간단하게 테스트해 본 결과, msw도입을 위해 필요한 파일들은 크게 3가지 종류로 나눌 수 있었어요.\n\n1. API 핸들러\n2. Mock 데이터\n3. 브라우저 환경에서 실행할 수 있게 도와주는 Worker함수\n\n따라서 각 파일들을 어떤 디렉터리에 위치시킬지 생각해보았어요.\n\n### 방법 1: API 경로 기반 구조\n\n첫번째로 고려한 방식은 API 주소를 기준으로 폴더를 구성하는 방식이에요.\n\n예를 들어 `http://localhost/test/verification`이라는 API를 Mocking한다고 했을 때, 파일구조는 아래와 같이 작성됩니다.\n\n```\nsrc\n├── __mocks__/\n│   ├── localhost/\n│   │   └── test/\n│   │       └── verification\n│   ├── handlers.ts\n│   └── browser.ts\n```\n\n**장점은 다음과 같아요.**\n\n- **직관적인 경로:** API 경로를 기반으로 하는 구조는 파일 시스템에서 해당 API를 쉽게 찾을 수 있게 해줍니다. 이는 특히 큰 프로젝트에서 API를 빠르게 찾아 수정해야 할 때 유용해요.\n- **변경 관리 용이:** 특정 API에 대한 변경 사항이 있을 때, 관련 파일을 찾아 수정하기가 간편합니다.\n\n**단점은 다음과 같아요.**\n\n- **중복된 구조:** 여러 API가 비슷한 데이터 구조를 공유할 경우, 코드와 mock 데이터의 중복이 발생할 수 있습니다.\n- **스케일링 문제:** 프로젝트 규모가 커지면 폴더 구조가 깊어지고 복잡해질 수 있습니다.\n\n### 방법 2: Mock 데이터 중심 구조\n\n두번째로 고려해 본 방식은 Mock 데이터만 별도로 관리하고 핸들러는 한 곳에 모으는 방식입니다.\n\n```\nsrc\n├── server/\n│   ├── __mocks__/\n│   │   └── userList.ts/\n│   ├── handlers.ts\n│   └── browser.ts\n```\n\n**장점은 다음과 같아요.**\n\n- **데이터 중심:** 공통된 데이터 구조를 사용하는 API들이 많은 경우, mock 데이터를 중앙에서 관리함으로써 중복을 줄일 수 있습니다.\n- **유연성:** 데이터 변경이 필요할 때 한 곳에서 관리하기 때문에, 데이터의 일관성을 유지하기가 용이합니다.\n\n**단점은 다음과 같아요.**\n\n- **핸들러 관리:** 모든 핸들러를 한 곳에 모으게 되면, 파일이 방대해지고 관리가 어려워질 수 있습니다.\n- **데이터와 핸들러의 분리:** 데이터와 핸들러가 분리되어 있어, 관련 핸들러와 데이터 사이의 연결을 파악하기 어려울 수 있습니다.\n\n### 방법 3: 도메인별 구조\n\n세번째로 고려한 방식은 도메인별로 핸들러와 데이터를 모아두는 방식이에요.\n\n```\nsrc\n├── mocks/\n│   ├── domain/\n│   │   └── album/\n│   │       ├── data.ts\n│   │       └── handlers.ts\n│   ├── handlers.ts\n│   └── browser.ts\n```\n\n**장점은 다음과 같아요.**\n\n- **도메인 중심:** 서비스의 기능별로 구분되어 있어, 관련 기능을 개발할 때 모든 관련 파일을 쉽게 찾을 수 있습니다.\n- **유지보수 용이:** 각 도메인별로 핸들러와 데이터를 분리함으로써, 유지보수가 용이합니다. 특정 기능에 문제가 생겼을 때, 해당 도메인의 폴더만 확인하면 됩니다.\n- **확장성:** 새로운 기능이나 도메인이 추가될 때, 새로운 폴더를 만들어 그 안에 모든 관련 파일을 배치함으로써 확장성이 높습니다.\n\n**단점은 다음과 같아요.**\n\n- **공통 데이터 관리:** 여러 도메인에서 공통적으로 사용되는 데이터가 있을 경우, 이를 어떻게 관리할지 고민이 필요합니다.\n- **API 간 데이터 공유의 어려움:** 특정 도메인에서만 사용되는 데이터가 아닌, 전역적으로 사용되는 데이터의 경우, 어느 도메인에 속해야 할지 결정하기 어려울 수 있습니다.\n\n### 그로잉은요?\n\n그로잉 서비스는 각 기능별로 구분된 도메인이 명확하기 때문에, 3번 방식이 가장 적합하다고 판단했어요.\n\n그리고 기존에 외부 라이브러리는 libs폴더에 정의해두고 사용했지만, msw 관련 파일은 mocks폴더에 전부 모아두기로 했어요. 빌드시 필요없는 코드와 파일들을 한 곳에 몰아넣기 위함이에요.\n\n또한 3번 방식처럼 도메인별 핸들러 함수를 한 파일에 전부 정의해두는 것보다는 분리한 후 index 파일에서 취합해서 내보내기로 했어요. API별 데이터들과 params, 200일때, 400일때 케이스들을 한 파일에 모두 작성하면 코드의 길이가 너무 길어져서 가독성을 해칠 것이라고 판단했기 때문이에요.\n\n따라서 아래와 같이 폴더 구조를 정할 수 있었어요.\n\n```\nsrc\n├── mocks/\n│   ├── user/\n│   │   ├── index.ts\n│   │   ├── getUserHandler.ts\n│   │   └── anotherHandler.ts\n│   ├── handlers.ts // 도메인별 핸들러 함수를 모두 취합하는 곳이에요.\n│   ├── browser.ts // worker를 정의해 둔 파일이에요.\n│   └── msw.ts // enableMocking() 함수를 정의해 둔 파일이에요.\n```\n\n아래는 예시입니다.\n\n```tsx\n// mocks/user/getUserHandler.ts\ntype Params = {\n  userId: string\n}\n\nconst data: UserDto = {\n  id: \"1\",\n  nickName: \"곰곰곰\",\n  birthDay: \"2000-01-01\",\n  anniversaryDay: \"2023-12-16\",\n}\n\nexport const getUserHandler = () => {\n  http.get<Params, null, UserDto, \"/user/:userId\">(\n    \"/user/:userId\",\n    async ({ params }) => {\n      const { userId } = params\n\n      await delay(1000)\n\n      return HttpResponse.json(data)\n    }\n  )\n}\n\n// mocks/user/index.ts\nimport { getUserHandler } from \"./getUserHandler\"\nimport { anotherHandler } from \"./anotherHandler\"\n\nexport const UserHandlers = [getUserHandler, anotherHandler]\n```\n\n그러나 이 방식은 일부 도메인에는 적용할 수 없었어요.\n\nGET, POST, DELETE 하는 API 가 같은 데이터를 바라봐야 했기 때문이죠. 만약 기존 데이터를 DELETE 요청으로 지운 후에 GET 요청을 했을 때, 지운 데이터가 남아 있다면 테스트할 때 불편하다고 판단했어요.\n\n### 최최최최종.jpg\n\n따라서 데이터를 공유해야하는 API 들은 한 파일 안에 작성해두는 것으로 변경했어요.\n\n```\nsrc\n├── mocks/\n│   ├── user/\n│   │   ├── getUserHandler.ts // 데이터를 공유할 필요없는 API\n│   │   ├── ...\n│   │   └── index.ts\n│   ├── chat/\n│   │   ├── data/\n│   │   │   ├── chatData.ts // 공유할 데이터\n│   │   │   └── image.png\n│   │   ├── chatHandler.ts // 공유할 데이터들을 사용하는 API들\n│   │   ├── chatQuestionHandler.ts\n│   │   └── index.ts\n│   ├── handlers.ts\n│   └── browser.ts\n```\n\n## 에러 응답 목업은 어떻게 하지? 🤔\n\n애플리케이션은 완벽할 수 없습니다. 네트워크 에러나 우리가 미처 처리하지 못한 예외 등으로 인해 생각한 대로 동작하지 않기도 해요. 그렇기 때문에 성공적인 응답만 mocking하는 것으로는 부족합니다. 이번 절에서는 에러 응답에 대한 모킹 방법에 대해 알아볼게요.\n\n### MSW 공식 문서 살펴보기\n\nMSW의 공식 문서에서 다음과 같은 에러 응답 목업 방식에 대해 찾을 수 있었어요.\n\n- status code 설정하기\n\n  ```jsx\n  export const handlers = [\n    http.delete(\"/posts/:id\", ({ params }) => {\n      const { id } = params\n      const deletedPost = allPosts.get(id)\n\n      if (!deletedPost) {\n        return new HttpResponse(null, { status: 404 })\n      }\n\n      allPosts.delete(id)\n\n      return HttpResponse.json(deletedPost)\n    }),\n  ]\n  ```\n\n  → 조건에 따라 에러를 나타내는 status를 함께 반환하는 방식이에요.\n\n- Network Error\n\n  ```jsx\n  import { http, HttpResponse } from \"msw\"\n\n  export const handlers = [\n    http.get(\"/resource\", () => {\n      return HttpResponse.error()\n    }),\n  ]\n  ```\n\n  → 네트워크 에러의 경우 위와 같이 HttpResponse.error()를 반환해요.\n\n- dynamic mock scenarios\n\n  ```jsx\n  import { http, HttpResponse } from \"msw\"\n\n  export const scenarios = {\n    success: [\n      http.get(\"/user\", () => {\n        return HttpResponse.json({ name: \"minju\" })\n      }),\n    ],\n    error: [\n      http.get(\"/user\", () => {\n        return new HttpResponse(null, { status: 500 })\n      }),\n    ],\n  }\n  ```\n\n  → 응답에 성공하는 경우와, 에러인 경우를 시나리오로 작성할 수 있어요. url 뒤에 `?scenario=error` 을 붙이면 오류 응답을 반환하는 경우에 어떻게 작동하는지 런타임에서 확인할 수 있어요.\n\n### 그로잉에서 선택한 에러 목업\n\n저희는 런타임에서 여러 기능들의 성공과 실패의 조합에 따라 테스트를 할 수 있는 방식이 필요했어요. msw에서 제공해주는 dynamic mock scenarios를 사용해 이를 구현하려면 url이 바뀌여야 하고, 한 페이지에 있는 여러 기능에 대해 각 시나리오를 식별하도록 코드를 추가로 작성해야 합니다. 그래서 저희는 status code를 런타임에 다르게 설정하는 방식을 사용하기로 했고, 여러 조합을 편하게 테스트할 수 있게 도와주는 툴바를 제작하기로 했어요.\n\n<br />\n\n> 🤔 어떻게 MSW Toolbar를 만들었는지 궁금하다면? ➡️ [다음글에서 계속](https://teamgrowing.github.io/team-blog/msw-toolbar)\n"},{"excerpt":"안녕하세요. 그로잉 FE팀입니다! 😀 현재, 저희는 그로잉 프로젝트 리팩토링을 앞두고 있어요. 작성한지 1-2년 된 코드였기에 본격적인 리팩토링을 시작하기 전, 사용하지 않는 파일들을 정리하고 폴더 구조를 다듬을 필요가 있었어요. 프로젝트의 폴더 구조를 잘 정의하는 것은 앞으로의 개발 효율성에 영향을 주는 중요한 요소이기도 하죠. 순간의 선택이 10년을 …","fields":{"slug":"/folder-structure/"},"frontmatter":{"date":"February 23, 2024","title":"행복한 개발을 위한 폴더 구조는?","tags":["growing","folder-structure"]},"rawMarkdownBody":"\n![출처: 추억의 금성사 월페이퍼 디자인 by.비범한츈](main-image.png)\n\n안녕하세요. 그로잉 FE팀입니다! 😀\n\n현재, 저희는 그로잉 프로젝트 리팩토링을 앞두고 있어요.\n\n작성한지 1-2년 된 코드였기에 본격적인 리팩토링을 시작하기 전, 사용하지 않는 파일들을 정리하고 폴더 구조를 다듬을 필요가 있었어요. 프로젝트의 폴더 구조를 잘 정의하는 것은 앞으로의 개발 효율성에 영향을 주는 중요한 요소이기도 하죠. 순간의 선택이 10년을 좌우한다는 말이 있듯, 앞으로의 리팩토링 효율성을 좌우할 폴더 구조를 어떻게 개편했을까요?\n\n저희가 파악한 그로잉 프로젝트의 폴더 구조의 문제점은 총 4가지가 있었어요.\n\n## 문제점 1: 폴더의 이름과 역할의 모호함\n\n첫번째로 발견한 문제점은 폴더의 이름과 이에 따른 역할이 불분명하다는 것입니다. 폴더의 이름과 폴더 내부 파일의 역할이 잘 맞게 개선하기 위해 다음과 같이 폴더 구조를 변경했어요.\n\n### 1. services, util → apis, libs, utils\n\n저희가 기존에 정의했던 폴더 구조에는 services폴더가 있었어요. services에는 비즈니스 로직을 모아두기로 했는데, 비즈니스 로직의 범위가 애매해 api들을 정의해두는 곳으로 사용했어요. 그리고 라이브러리와 관련된 코드, 프로젝트의 여러 곳에서 재사용되는 간단한 함수 등은 util폴더에 넣었습니다.\n\n**한 폴더에 여러 역할의 파일들이 들어가 있다는 문제**를 해결하기 위해 services와 utils폴더를 apis, libs, utils 총 3개의 폴더로 분리하기로 결정했어요.\n\n- **apis**\n  ![](apis-image.png)\n\n  백엔드 서버에 요청을 보내기 위한 api를 저장하기 위한 폴더입니다. 데이터와 관련된 요청을 위한 로직만 모여있기 때문에 services라는 이름 보다 apis가 더 적절하다고 생각해 이름을 변경했어요.\n\n- **libs**\n  ![](libs-image.png)\n\n  외부 라이브러리와 관련된 파일들을 모아두기 위한 폴더입니다. text 가공을 위한 로직, 비디오를 다루기 위한 로직 등이 담겨있어요.\n\n- **utils**\n  ![](utils-image.png)\n\n  그 외 프로젝트 전반에서 사용되는 잡다한 코드들을 위한 폴더입니다. 그로잉 프로젝트에서 사용하고 있는 react-query, dayjs, react-hook-form 등의 라이브러리를 사용하는 데 필요한 로직들이 담겨있어요.\n\n### 2. types → models\n\n기존의 폴더구조에서는 types라는 폴더에 dto, 컴포넌트에서 필요한 각종 type들, 스타일에 필요한 type들이 모두 섞여있어 원하는 파일을 찾기 어렵다는 문제가 있었습니다. 이를 해결하기 위해 models 폴더를 따로 만들어 파일들을 역할에 따라 분리했어요.\n\n- **models**\n  ![](models-image.png)\n\n  기존에는 `types/chat/` 폴더의 하위에 `chatLine.dto.ts`, `chat.dto.ts` 등으로 하나의 dto를 하나의 파일에 작성했었는데 이를 기능에 따라 그룹화해 `models/` 에 위치 시켰습니다. 이렇게 하면, 한 파일로 여러 dto들을 모아 두면 다른 파일에서 dto를 import할 때 import문이 간략해진다는 장점이 있어요. 그리고 models 에는 백엔드와의 데이터 교환을 도와주는 dto들을 모아두었습니다.\n\n- **types**\n  ![](types-image.png)\n  dto 외의 font, style을 위한 타입들을 위한 폴더입니다.\n\n위와 같이 세부적으로 폴더를 분리해 로직의 역할에 따라 파일들을 분류할 수 있었습니다. 사실 dto 파일들은 api와 관련된 파일들이기 때문에 apis폴더 안에 위치시키는 것이 좋을 지에 대한 고민이 있었어요. 하지만 정의된 dto들이 apis폴더에 있는 파일 뿐 아니라 react-query를 위한 쿼리들이나 컴포넌트 파일에서도 사용되기 때문에 `src/models` 폴더에 위치시키기로 했습니다.\n\n## 문제점 2: 컴포넌트 파일 내 스타일 코드 혼재\n\n두번째로는 컴포넌트 파일 내에 스타일 관련 코드가 혼재되어 있어서, 파일의 복잡성이 증가하고 가독성이 떨어지는 문제점이 있었어요.\n\n```tsx\nconst Title = styled.div`\n  width: 100%;\n  font-family: 'PretendardBold';\n  font-size: 17px;\n  color: ${({ theme }) => theme.color.gray50};\n  text-align: center;\n`;\nconst Description = styled.div`\n  width: 100%;\n  font-size: 14px;\n  color: ${({ theme }) => theme.color.gray50};\n  text-align: center;\n  white-space: pre-wrap;\n  word-break: break-all;\n`;\nconst Buttons = styled.div`\n  width: 100%;\n  border-top: 0.5px solid ${({ theme }) => theme.color.gray50}50;\n  display: flex;\n`;\n\nexport default function Modal({\n  onModal,\n  setOnModal,\n\t...\n}: ModalProps) {\n  if (!onModal) {\n    return null;\n  }\n\n  return (\n    <ModalPortal>\n      <Overlay />\n      <Wrapper>\n        <Main>\n          {title && <Title className=\"text-ellipsis\">{title}</Title>}\n          {description && <Description>{description}</Description>}\n        </Main>\n        <Buttons>\n\t\t\t   {/* */}\n        </Buttons>\n      </Wrapper>\n    </ModalPortal>\n  );\n}\n```\n\n따라서 스타일 파일을 따로 분리하기로 결정했어요.\n\n```tsx\nsrc\n└── components\n    └── Header\n        ├── Header.tsx  // 컴포넌트 로직 파일\n        └── Header.styled.ts  // 스타일 파일\n```\n\n사용할 때는 해당 스타일을 사용하는 컴포넌트 파일에서 스타일을 import하여 사용합니다.\n\n```tsx\n// Header.tsx\nimport S from './Header.styles';\n\nconst Header = () => {\n  return (\n    <S.HeaderContainer>\n      <S.Logo>그로잉</Logo>\n      {/* 나머지 컴포넌트 내용 */}\n    </S.HeaderContainer>\n  );\n};\n\nexport default Header;\n```\n\n이를 통해 스타일과 컴포넌트 로직의 분리를 더욱 명확히 할 수 있었고, 스타일 변경 시 해당 스타일 파일만 수정하면 되므로 유지보수성이 향상되는 효과도 얻을 수 있었어요.\n\n## 문제점 3 : 응집도 부족\n\n기존의 폴더구조에서는 `src/components/pages/` 형태로 페이지 별로 컴포넌트를 분리했고 `src/pages`에는 페이지 컴포넌트만 있었어요. 예를 들어, `src/components/gallery/` 에 있는 컴포넌트들을 사용해 `src/pages/GalleryPage.tsx` 를 구성하는 방식이에요.\n\n이 경우에는 페이지를 기준으로 폴더를 나누기 때문에 components폴더 처럼 다른 폴더들에서도 페이지별 폴더가 필요했어요. (ex. `components/gallery`, `hooks/gallery`). 그렇다보니 컴포넌트의 이름이 바뀌면 이와 관련된 파일이 이곳저곳에 분산 되어 있어 수정하기 번거롭다는 문제가 생겼어요.\n\n그래서 저희는 파일 유형에 따라 분류를 했던 폴더 구조에서 도메인(기능)에 따라 분류를 하는 폴더 구조로 전환했습니다.\n\n- components 폴더에는 프로젝트에서 공통으로 사용할 컴포넌트를 모아둡니다.\n  ![](components-image.png)\n\n- 도메인별 페이지, 해당 도메인 내에서 사용되는 컴포넌트와 훅들은 모두 pages에 모아둡니다.\n\n  <img src='login-image.png' width='200px'/>\n\n위와 같이 폴더 구조를 변경한 후, 각 기능별 페이지 폴더 안에 필요한 파일들이 들어있는 형태가 되어 도메인별로 응집도를 높일 수 있었어요.\n\n## 문제점 4: 베럴 파일 적용\n\n현재 그로잉 프로젝트에는 모듈 import문이 복잡하다는 문제가 있었어요.\n\n```tsx\n// 단일 컴포넌트 직접 임포트\nimport Modal from \"components/common/Modal/Modal\"\nimport AlbumModal from \"components/common/AlbumModal/AlbumModal\"\n```\n\n이러한 모듈 import의 복잡성을 줄이기 위해 베럴 파일을 도입하는 것 전략을 고려하게 되었습니다.\n\n아래와 같이 베럴 파일을 도입한다면 여러 하위 모듈을 한 곳에서 관리함으로써, 임포트 경로를 간소화하고 코드의 가독성을 향상시킬 수 있어요.\n\n```tsx\n// src/components/common/index.ts\nexport { default as Modal } from \"./Modal\"\nexport { default as AlbumModal } from \"./AlbumModal\"\n\n// 사용하는 곳.tsx\nimport { Modal, AlbumModal } from \"components/common\" // 간단\n```\n\n그러나 베럴 파일 사용에는 몇 가지 고려해야 할 사항이 있다고 해요. 특히, 대규모 프로젝트의 경우 다음과 같은 이유로 주의가 필요합니다.\n\n1. **트리 쉐이킹(Tree Shaking) 최적화**\n\n   웹팩(Webpack)과 같은 모듈 번들러는 사용되지 않는 코드를 제거하는 트리 쉐이킹 과정을 통해 최종 번들의 크기를 줄입니다. 베럴 파일을 통해 모든 모듈을 임포트하면, 실제로 사용되지 않는 모듈까지 번들에 포함될 가능성이 있어 트리 쉐이킹의 효율성이 떨어질 수 있습니다.\n\n2. **코드 스플리팅(Code Splitting) 최적화**\n\n   베럴 파일을 사용하면, 필요한 컴포넌트만을 로드하는 대신 관련된 모든 컴포넌트가 함께 로드될 수 있습니다. 이는 초기 로딩 시간에 부정적인 영향을 줄 수 있으며, 특히 대규모 애플리케이션에서는 성능 저하의 원인이 될 수 있습니다.\n\n이러한 이유로, 베럴 파일의 사용을 재고하고 프로젝트의 현재 방식을 유지하기로 결정했어요.\n\n## 결론\n\n결론적으로, 그로잉 프로젝트의 폴더구조는 이렇게 바뀌었답니다!\n\n**😠 변경 이전의 폴더 구조**\n\n```jsx\n.storybook // Storybook 설정 폴더\n\npublic // 이미지, 아이콘 등\n\nsrc\n ├── assets\n │   ├── fonts\n │   ├── icons\n │   └── image\n │\n ├── components\n │   │   └─common // 공통으로 사용되는 컴포넌트\n │   │\n │   ├── pages // 페이지별 컴포넌트 모음\n │   │   ├── main // 메인 화면\n │   │   │\t ├─ Banner.tsx\n │   │   │   └─ ContentsTile.tsx\n │   │   │\n │   │   ├── contents // 콘텐츠 화면\n │   │   │\t ├─ Banner.tsx\n │   │   │   └─ ContentsTile.tsx\n │\n ├── constants\n ├── hooks\n ├── pages\n │   ├─ Main.tsx\n │   ├─ ContentsHome.tsx\n │   └─ ...\n │\n ├── services\n ├── styles\n ├── types\n ├── util\n ├── stores\n │\n ├── App.tsx\n ├── index.tsx\n └── index.css\n\n.babelrc\n.eslintrc\n.gitignore\n.prettierrc\npakage.json\nREADME.md\n.tsconfig.json\nyarn.lock\n```\n\n**😊 변경된 폴더 구조**\n\n```jsx\n.storybook\npublic\n\nsrc\n├─apis // 백엔드 서비스와 상호작용을 위한 API 함수들\n├─assets\n│  ├─fonts\n│  ├─icons\n│  └─image\n├─components // 재사용 가능한 UI 컴포넌트들\n│  ├─common // 애플리케이션 전반에 걸쳐 사용되는 일반 컴포넌트들 (버튼, 입력창 등)\n│  └─layout // 애플리케이션의 레이아웃과 관련된 컴포넌트들 (헤더, 푸터, 사이드바 등)\n│\n├─constants\n├─hooks // 컴포넌트 간에 공유되는 로직을 위한 커스텀 React 훅\n├─libs // 프로젝트 내에서 쉽게 사용할 수 있도록 외부 라이브러리를 감싸는 라이브러리나 유틸리티들\n├─mocks // 테스팅 및 개발을 위한 모의 데이터와 함수들\n├─models // 비즈니스 엔티티와 관련된 데이터 모델과 타입, 주로 TypeScript 타입 정의\n├─pages\n│  ├─calendar\n│  │  ├─CalendarPage // 캘린더 페이지를 위한 메인 컴포넌트\n│  │  └─components // 캘린더 기능과 관련된 하위 컴포넌트들\n│  │      ├─...\n│  ├─chat\n│  ├─gallery\n│  ├─home\n│  ├─login\n│  └─more\n├─stores\n├─styles\n├─types // 비즈니스 모델과 직접적으로 관련되지 않은 TypeScript 타입 정의들\n└─utils // 애플리케이션 전반에 걸쳐 공통적으로 사용되는 유틸리티 함수들 (포맷팅, 검증 등)\n\n.babelrc\n.eslintrc\n.gitignore\n.prettierrc\npakage.json\nREADME.md\n.tsconfig.json\nyarn.lock\n\n```\n\n폴더 구조에는 하나의 정답이 있는 것이 아니라, 일관성을 유지하고, 팀 내에서 모두가 이해하고 따를 수 있는 명확한 규칙을 설정한다는 것에 의미가 있다고 생각해요. 그러므로 프로젝트의 규모, 팀의 작업 스타일, 그리고 향후 유지보수와 확장 계획 등을 고려해 자신의 프로젝트에 맞는 폴더 구조를 구성하는 것이 중요한 것 같습니다.\n\n## Reference\n\n- https://github.com/yeonjuan/dev-blog/blob/master/JavaScript/speeding-up-the-javascript-ecosystem-the-barrel-file-debacle.md\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}