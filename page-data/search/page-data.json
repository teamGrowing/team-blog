{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"툴바를 만들자! 저희 그로잉팀은 런타임에서 여러 기능들의 성공과 실패의 조합에 따라 테스트를 할 수 있는 방식이 필요했고, 이를 MSW Toolbar를 만들어 해결했어요. 이번 글에서는 MSW Toolbar 제작 과정을 소개할게요. 정의된 핸들러 리스트 받아오기 툴바 구현을 위해 먼저 정의해 둔 핸들러 리스트 정보들을 가져올 수 있는 지가 가장 중요했어요…","fields":{"slug":"/msw-toolbar/"},"frontmatter":{"date":"February 25, 2024","title":"API 요청 시뮬레이션을 간편하게: 그로잉 팀의 MSW Toolbar 도입기","tags":["growing","msw","mocking"]},"rawMarkdownBody":"\n## 툴바를 만들자!\n\n저희 그로잉팀은 런타임에서 여러 기능들의 성공과 실패의 조합에 따라 테스트를 할 수 있는 방식이 필요했고, 이를 MSW Toolbar를 만들어 해결했어요.\n\n이번 글에서는 MSW Toolbar 제작 과정을 소개할게요.\n\n<div align='center'>\n    <img src='msw.gif' width='300px'  />\n</div>\n\n### 정의된 핸들러 리스트 받아오기\n\n툴바 구현을 위해 먼저 정의해 둔 핸들러 리스트 정보들을 가져올 수 있는 지가 가장 중요했어요. 따라서 해당 정보를 받아올 수 있는지 확인하는 작업을 먼저 진행했어요.\n\n```tsx\n// App.ts\nimport { handlers } from \"mocks/handlers\"\n\n// 각 핸들러의 경로와 메소드 정보를 콘솔에 출력\nhandlers.forEach(handler => {\n  const { path, method } = handler.info // 핸들러의 정보에서 경로와 메소드 추출\n  console.log({ path, method })\n})\n```\n\n다행히도 MSW 핸들러에서 제공하는 정보를 활용하여, 간단한 코드 몇 줄로 원하는 핸들러 정보를 추출할 수 있었어요.\n\n![](handler-list-image.png)\n이렇게 콘솔에 출력된 정보를 바탕으로, 핸들러 정보를 관리하는 클래스나 객체를 구성하여 필요할 때마다 활용하면 될 것 같네요!\n\n### UI\n\n툴바의 UI는 피그마를 사용하여 디자인했습니다. 툴바에 포함될 주요 기능은 다음과 같아요.\n\n1. **API 경로 검색**: 사용자가 특정 API 경로를 검색하여 해당하는 핸들러를 찾을 수 있습니다.\n2. **상태 코드 변경**: 성공 또는 에러 상태 코드를 동적으로 변경할 수 있어, 다양한 응답 시나리오를 시뮬레이션할 수 있습니다.\n3. **응답 지연 설정**: API 응답의 지연 시간을 설정하여 네트워크 지연 테스트를 할 수 있습니다.\n\n![](ui-image.png)\n\n### **핸들러 동적 변경 고려사항**\n\n상태 코드나 응답 지연 시간을 변경하려면, 기존의 핸들러 코드를 동적으로 조절할 필요가 있었어요. 예를 들어, 성공 응답과 에러 응답을 다루는 두 가지 핸들러가 있다고 가정해 보겠습니다.\n\n```tsx\n// mocks/user/getUserHandler.ts\ntype Params = {\n  userId: string;\n};\n\nconst data: UserDto = {\n\tid: '1',\n\tnickName: '곰곰곰',\n\tbirthDay: '2000-01-01',\n\tanniversaryDay: '2023-12-16',\n};\n\n// 성공 응답 핸들러\nexport const getUserSuccessHandler = () => {\n\thttp.get<Params, null, UserDto, '/user/:userId'>(\n    '/user/:userId',\n    async () => {\n\t\t\tawait delay(1000); // 1초 지연\n\n      return HttpResponse.json(data, {\n\t      status: 200,\n\t      statusText: '요청에 상공했습니다.',\n\t\t});\n  });\n}\n\n// 실패 응답 핸들러\nexport const getUserErrorHandler = () => {\n\thttp.get<Params, null, null, '/user/:userId'>(\n    '/user/:userId',\n    async () => {\n\t\t\tawait delay(500); // 0.5초 지연\n\n      return HttpResponse.json(null, {\n\t      status: 400,\n\t      statusText: '요청에 실패했습니다.',\n    }),\n  });\n}\n```\n\n세 부분에서 변경이 일어나는 것을 알 수 있어요.\n\n1. **응답 타입**: 성공과 실패 응답의 타입이 다를 수 있습니다.\n2. **지연 시간**: `delay` 함수의 인자를 통해 응답 지연 시간을 설정합니다.\n3. **응답 데이터**: `HttpResponse.json` 메소드의 인자로 전달되는 데이터입니다.\n\n따라서 이 요소들을 런타임에 동적으로 바꿔줄 수 있어야 했어요. 이를 하드코딩이 아닌 변수로 지정해두고 동적으로 바꿔주면 될 것 같아요.\n\n### 해당하는 URL에 맞는 핸들러 찾는 법\n\n그렇다면 검색한 API URL에 맞는 핸들러는 어떻게 찾을 수 있을까요?\n\n같은 URL에 대해 다른 HTTP 메소드(GET, POST, DELETE 등)를 사용하는 경우가 많기 때문에, 단순히 URL만으로 핸들러를 찾는 것은 충분하지 않았아요.\n\n이를 해결하기 위해 핸들러 정보를 저장할 때 URL 경로와 HTTP 메소드의 조합을 고유한 식별자로 사용하기로 결정했어요.\n\n```tsx\ninterface HandlerInfoList {\n  [path: string]: {\n    [method: string]: HandlerInfo\n  }\n}\n```\n\n![](url-search-image.png)\n\n### HandlerInfoManager 구현과 활용\n\n핸들러들을 저장하고 꺼내오고 delay 변수값들을 변경시켜주는 작업을 저희 그로잉 팀은 HandlerInfoManager 클래스를 제작하여 해결하였어요.\n\n```tsx\nimport { handlers } from \"mocks/handlers\"\n\nconst DEFAULT_STATUS = 200\nconst DEFAULT_DELAY = 1000\n\ntype StatusType = 200 | 400\n\ninterface HandlerInfo {\n  status: StatusType\n  delayTime: number\n}\n\ninterface HandlerInfoList {\n  [path: string]: {\n    [method: string]: HandlerInfo\n  }\n}\n\ninterface HandlerInfoParams {\n  path: string\n  method: string\n  code: StatusType\n  time: number\n}\n\nclass HandlerInfoManager {\n  private handlerInfos: HandlerInfoList = {}\n\n  // 핸들러 정보 초기화\n  public initHandlerInfo(): void {\n    handlers.forEach(handler => {\n      const { path, method } = handler.info\n      this.setHandlerInfo({\n        path: path.toString(),\n        method: method.toString(),\n        code: 200, // 기본 상태 코드\n        time: 1000, // 기본 지연 시간\n      })\n    })\n  }\n\n  // 핸들러 정보 설정\n  public setHandlerInfo({ path, method, code, time }: HandlerInfoParams): void {\n    if (!this.handlerInfos[path]) {\n      this.handlerInfos[path] = {}\n    }\n    this.handlerInfos[path][method] = { status: code, delayTime: time }\n  }\n\n  // 핸들러 리스트 조회\n  public getHandlerInfos(): HandlerInfoList {\n    return this.handlerInfos\n  }\n\n  // 특정 핸들러 정보 조회\n  public getHandlerInfo(path: string, method: string): HandlerInfo | undefined {\n    return this.handlerInfos[path]?.[method]\n  }\n}\n\nexport const handlerInfoManager = new HandlerInfoManager()\n```\n\n이렇게 `HandlerInfoManager`를 사용하면 핸들러의 상태 코드와 지연 시간을 런타임에 변경할 수 있으며, 툴바 UI에서 사용자의 입력에 따라 이러한 변경을 적용할 수 있습니다.\n\n### 사용 예시\n\n사용 예시는 다음과 같아요.\n\n```tsx\nimport { handlerInfoManager } from \"mocks/HandlerInfoManager\"\nimport { CoupleDto } from \"models/couple\"\nimport { delay, http, HttpResponse } from \"msw\"\n\ninterface Params {\n  coupleId: string\n}\n\nconst data: CoupleDto = {\n  coupleId: \"1\",\n  myName: \"연주\",\n  partnerName: \"민지\",\n  dayCount: 10,\n  petId: null,\n}\n\nexport const getCoupleHandler = http.get<Params, {}, CoupleDto | null>(\n  \"/couples/:coupleId\",\n  async () => {\n    const responseList = {\n      200: HttpResponse.json(data, {\n        status: 200,\n        statusText: \"success\",\n      }),\n      400: HttpResponse.json(null, {\n        status: 400,\n        statusText: \"fail\",\n      }),\n    }\n\n    const handler = handlerInfoManager.getHandlerInfo(\n      \"/couples/:coupleId\",\n      \"GET\"\n    )\n\n    const status = handler?.status || 200\n    const delayTime = handler?.delayTime || 0\n\n    await delay(delayTime)\n    return responseList[status]\n  }\n)\n```\n\n```tsx\nconst handleClick = (path: string, method: string) => {\n  handlerInfoManager.setHandlerInfo({ path, method, code: 400, time: 3000 })\n}\n```\n\n### 추상화를 해보자\n\n모든 API 핸들러에서 반복적으로 나타나는 패턴들은 무엇이 있을까요?\n\n코드를 분석해 본 결과 다음 코드가 반복해서 작성되어야 했어요. 이를 추상화하여 코드 중복을 줄여볼게요.\n\n```tsx\nconst handler = handlerInfoManager.getHandlerInfo(\"/couples/:coupleId\", \"GET\")\n\nconst status = handler?.status || 200\nconst delayTime = handler?.delayTime || 0\n\nawait delay(delayTime)\nreturn responseList[status]\n```\n\n```tsx\nimport { handlerInfoManager } from \"mocks/HandlerInfoManager\"\nimport { delay, http } from \"msw\"\n\n// 상태 코드별 응답 데이터를 매핑하는 객체 타입을 정의합니다.\ntype ResponseData<TResponse> = {\n  [key: number]: TResponse | null\n}\n\n// API 요청 처리 함수 타입을 정의합니다.\ntype RequestHandler<TParams, TResponse> = (\n  params: TParams\n) => ResponseData<TResponse>\n\n// 범용 API 핸들러 생성 함수를 정의합니다.\nexport const createApiHandler = <TParams, TResponse>(\n  path: string,\n  method: keyof typeof http,\n  handleRequest: RequestHandler<TParams, TResponse>\n) => {\n  return http[method](path, async req => {\n    const params = req.params as TParams\n    const handler = handlerInfoManager.getHandlerInfo(path, method)\n    const delayTime = handler?.delayTime || 0\n    const responseStatus = handler?.status || 200\n\n    await delay(delayTime)\n\n    const responseData = handleRequest(params)\n    return responseData[responseStatus]\n  })\n}\n```\n\n이 추상화를 통해 아래처럼 간편하게 개별 핸들러들을 구현할 수 있게 되었어요. 각 API 핸들러마다 상태 코드와 지연 시간을 처리하는 로직을 반복해서 작성할 필요가 없어진거죠.\n\n```tsx\n// 사용 예시: 커플 정보 조회 API 핸들러\ninterface Params {\n  coupleId: string\n}\n\nconst data: CoupleDto = {\n  coupleId: \"1\",\n  myName: \"연주\",\n  partnerName: \"민지\",\n  dayCount: 10,\n  petId: \"1\",\n}\n\nexport const getCoupleHandler = createApiHandler<Params, CoupleDto | null>(\n  \"/couples/:coupleId\",\n  \"get\",\n  () => ({\n    // 여기서는 단순화를 위해 바로 데이터를 반환하지만,\n    // 실제로는 params를 기반으로 데이터를 조회하거나 처리할 수 있습니다.\n    200: data, // 성공 응답\n    400: null, // 실패 응답\n  })\n)\n```\n\n## 그러나,,\n\n처음에 생각한 기능들 외에 추가로 필요한 기능들이 있었어요. 처음에는 Path Parameter만 필요했었지만 Query Parameter가 필요한 경우도 있었어요.\n\n> Parameter type\n>\n> 1. Query parameters: `?a=1&b=2`;\n> 2. Path parameters: `GET /user/:id`, where `id` is a path parameter.\n\n그리고 API 호출 성공 후에 로직을 처리할 콜백 함수가 필요했어요. DELETE 요청 후에 기존 data를 삭제하거나, PATCH 후에 수정하는 코드가 필요했기 때문이에요.\n\n이러한 추가 요구사항을 충족하기 위해 다음과 같이 `createApiHandler` 함수를 확장했어요.\n\n```tsx\n// ApiHandlerCreator.ts\nimport { DefaultBodyType, PathParams, delay, http, HttpResponse, StrictRequest } from 'msw';\nimport { handlerInfoManager } from './HandlerInfoManager';\n\n// 응답 데이터 타입 정의: 상태 코드별로 응답 데이터를 매핑\ntype ResponseData<TResponse> = {\n  [status: number]: NullableResponse<TResponse>;\n};\n\n// 요청 처리 핸들러 타입 정의: 경로 및 요청 매개변수를 받아 응답 데이터를 반환\ntype RequestHandler<TParams, TRequest, TResponse> = (\n  params: TParams,\n  request: TRequest\n) => ResponseData<TResponse>;\n\n// 요청 처리 후 실행할 콜백 함수 타입 정의\ntype AfterRequest<TParams, TRequest> = (\n  params: TParams,\n  request: TRequest\n) => void;\n\n// 범용 API 핸들러 생성 함수\nexport const createApiHandler = <\n  TParams extends PathParams,\n  TRequest extends DefaultBodyType,\n  TResponse extends DefaultBodyType\n>(\n  path: string;\n  method: keyof typeof http;\n  requestHandler: RequestHandler<TParams, StrictRequest<TRequest>, TResponse>;\n  onSuccess?: AfterRequest<TParams, StrictRequest<TRequest>>;\n  ) => {\n  return http[method]<TParams, TRequest, TResponse>(\n    path,\n    async ({ params, request }) => {\n      // 요청 처리 함수를 호출하여 응답 데이터를 가져옴\n      const responseData = requestHandler(params, request);\n\n      // 핸들러 정보(응답 지연 시간 및 상태 코드) 조회\n      const handlerInfo = handlerInfoManager.getHandlerInfo(path, method);\n      const delayTime = handlerInfo?.delayTime || 0;\n      const responseStatus = handlerInfo?.status || 200;\n\n      // 응답 지연 시간 적용\n      await delay(delayTime);\n\n      // 성공적인 요청 처리 후 콜백 함수 실행\n      if (responseStatus !== 400) {\n        onSuccess?.(params, request);\n      }\n\n      // JSON 형태로 응답 반환\n      return HttpResponse.json(responseData[responseStatus], {\n        status: responseStatus,\n      });\n    }\n  );\n};\n```\n\n### 리팩토링: 파라미터 객체화\n\n함수의 매개변수가 많아짐에 따라 가독성과 사용성 문제가 발생했어요. 몇번째 파라미터에 어떤 값을 넣어줘야 할지 시각적으로 알아보기 어려웠기 때문이에요.\n\n이를 해결하기 위해 \"객체 비구조화 할당(destructuring)\" 기법을 적용하여 함수 매개변수를 객체화했습니다. 이 접근 방식을 통해 함수 호출 시 매개변수의 순서에 덜 의존할 수 있게 되었고, 코드의 가독성을 향상시킬 수 있었어요.\n\n```tsx\n// 변경전\nexport const deleteOurChatHandler = createApiHandler<\n  ChatDeleteParams,\n  {},\n  null\n>(\n  \"/couples/:coupleId/chattings/:chattingId/delete-ours\",\n  \"delete\",\n  () => ({\n    200: null,\n    400: null,\n  }),\n  ({ chattingId }) => {\n    chatData = chatData.filter(chat => chat.parentChatting.id !== chattingId)\n  }\n)\n```\n\n```tsx\n// 변경후\nexport const deleteOurChatHandler = createApiHandler<\n  ChatDeleteParams,\n  {},\n  null\n>({\n  path: \"/couples/:coupleId/chattings/:chattingId/delete-ours\",\n  method: \"delete\",\n  requestHandler: () => ({\n    200: null,\n    400: null,\n  }),\n  onSuccess: ({ chattingId }) => {\n    chatData = chatData.filter(chat => chat.parentChatting.id !== chattingId)\n  },\n})\n```\n\n### MSW 툴바 컴포넌트 제작하기\n\n이제 툴바 컴포넌트를 제작해 볼게요.\n\n<img src='selector-image.png' width='300px' />\n\n```tsx\n//MSWToolbar.tsx\nimport ...\n\nfunction MSWToolbar() {\n  const queryClient = useQueryClient();\n  const [open, setOpen] = useState(false)\n  const [items, setItems] = useState(\n    Object.entries(handlerInfoManager.getHandlerInfos())\n  )\n  const stagedValue = useRef<{\n    [path: string]: {\n      [method: string]: HandlerInfo\n    }\n  }>({})\n\n\n  const inputChangeHandler = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { value } = e.target\n    setItems(\n      Object.entries(handlerInfoManager.getHandlerInfos()).filter(([path]) =>\n        path.includes(value)\n      )\n    )\n  }\n\n  const clickApplyBtnHandler = () => {\n    Object.keys(stagedValue.current).forEach(path => {\n      Object.keys(stagedValue.current[path]).forEach(method => {\n        const { status, delayTime } = stagedValue.current[path][method]\n        handlerInfoManager.setHandlerInfo({\n          path,\n          method,\n          code: status,\n          time: delayTime,\n        })\n      })\n    })\n    stagedValue.current = {};\n    queryClient.invalidateQueries();\n    setOpen(false)\n  }\n\n  return (\n    <>\n      {!open && (\n        <S.ToolbarButton onClick={() => setOpen(true)}>MSW</S.ToolbarButton>\n      )}\n      {open && (\n        <ToolbarBottomSheet open={open} setOpen={setOpen}>\n          <S.SearchBar>\n            <Icon icon=\"IconSearch\" />\n            <S.Input onChange={inputChangeHandler} />\n          </S.SearchBar>\n          {items.length === 0 && (\n            <S.MessageBox>검색 결과가 없어요!</S.MessageBox>\n          )}\n          {items.length > 0 && (\n            <S.ItemsContainer className=\"hidden-scrollbar\">\n              {items.flatMap(([path, methods]) =>\n                Object.entries(methods).map(\n                  ([method, { delayTime, status }]) => (\n                    <ToolbarItem\n                      key={`${path}-${method}`}\n                      method={method}\n                      path={path}\n                      delayTime={delayTime}\n                      status={status}\n                      onChange={(time, code) => {\n                        stagedValue.current[path] =\n                          stagedValue.current[path] ?? {}\n                        stagedValue.current[path][method] = {\n                          status: code,\n                          delayTime: time,\n                        }\n                      }}\n                    />\n                  )\n                )\n              )}\n            </S.ItemsContainer>\n          )}\n          {items.length > 0 && (\n            <S.ButtonArea>\n              <S.Button onClick={clickApplyBtnHandler}>적용하기</S.Button>\n            </S.ButtonArea>\n          )}\n        </ToolbarBottomSheet>\n      )}\n    </>\n  )\n}\n\nexport default MSWToolbar;\n```\n\n툴바 컴포넌트의 전체 코드와 툴바의 옵션 선택 부분입니다. 코드의 동작 과정을 자세히 살펴볼게요.\n\n- `handlerInfoManager.getHandlerInfos()` 를 사용해 handler의 path와 method를 받아오고 있어요.\n- `inputChangeHandler` 는 검색 창의 input value가 변경되었을 때 호출되는 함수에요. 텍스트를 입력할 때마다 입력된 경로가 포함되는 요소들을 보여줍니다.\n- 각 핸들러에 대응되는 드롭다운 메뉴에서 옵션을 선택하면, 옵션을 stagedValue 변수에 저장합니다.\n- 적용하기 버튼을 누르면, `clickApplyBtnHandler` 가 실행되어 stagedValue에 저장된 옵션들(delay와 status code)이 실제 핸들러에 적용됩니다. 현재 그로잉 프로젝트에서는 react-query를 사용하고 있어서 옵션들을 적용한 후 바로 데이터를 refetch하도록 만들기 위해 마지막으로 `queryClient.invalidateQueries()` 를 실행해주고 있어요.\n- real은 현실적인 응답 시간 정도를 지연해주는 옵션입니다. infinite는 응답을 무한하게 delay 시켜주는 옵션입니다. 이는 로딩 상태가 잘 표시되는 지 등을 확인할 때 유용하게 사용할 수 있어요.\n\n#### 코드에서 한 가지 생각해볼 점이 있었어요.\n\n`const stagedValue = useRef<{[key: string]: SetHandlerParams;}>({});` 부분에서 왜 useRef 훅을 사용했을까요?\n\nstagedValue를 useRef없이 사용하면, 검색을 할 때마다 MSWToolbar 컴포넌트가 재실행 되어 stagedValue가 빈 객체로 초기화됩니다. 이를 방지하고자 useState 훅을 사용하면, stagedValue가 변경 될 때마다 리렌더링이 발생해요.\n\n그래서 컴포넌트가 재실행 되더라도 stagedValue값을 유지하면서, stagedValue가 변경되더라도 리렌더링이 일어나지 않게 하기 위해 useRef hook을 사용했어요.\n\n### 툴바는 리액트 돔 트리에서 어디에 위치해야 할까?\n\n```tsx\nconst root = ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement)\n\nenableMocking().then(() => {\n  root.render(\n    <React.StrictMode>\n      <BrowserRouter>\n        <QueryClientProvider client={queryClient}>\n          <ReactQueryDevtools initialIsOpen={false} />\n          <GlobalStyle />\n          <ThemeProvider theme={myTheme}>\n            {process.env.NODE_ENV === \"development\" && <MSWToolbar />}\n            <AsyncBoundary\n              pendingFallback={<FullScreenLoading />}\n              rejectedFallback={({ error, resetErrorBoundary }) => (\n                <FullScreenError\n                  error={error}\n                  resetErrorBoundary={resetErrorBoundary}\n                />\n              )}\n            >\n              <App />\n            </AsyncBoundary>\n          </ThemeProvider>\n        </QueryClientProvider>\n      </BrowserRouter>\n    </React.StrictMode>\n  )\n})\n```\n\n**다음은 MSWToolbar 컴포넌트의 위치를 선택할 때 고려한 내용들이에요.**\n\n1. MSWToolbar는 dev모드에서만 뜨도록 해야 합니다.\n2. MSWToolbar는 런타임에 영향을 주지 않아야 합니다.\n3. MSWToolbar에서 styled-component의 theme을 이용하고 있어 ThemeProvider 안에 들어가야 합니다.\n4. react query로 관리되고 있는 서버 데이터의 invalidate해줄 수 있어야 하므로 QueryClientProvider 안에 들어가야 합니다.\n\n1번을 위해 NODE_ENV에 따라 Toolbar를 표시해 주었고 2, 3번을 고려해 AsyncBoundary밖이면서 ThemeProvider와 QueryClientProvider의 안에 위치 시켰어요.\n\nMSWToolbar를 이용해 의도적으로 error 상황을 테스트할 때, 그로잉 프로젝트에서 AsyncBoundary와 함께 사용하고 있는 FullScreenError가 뜰 수 있어요. 이때, MSWToolbar는 런타임에서 발생하는 에러 범위 밖에서 상태코드를 200으로 바꿔줄 수 있어야 하기 때문에 AsyncBoundary밖에 위치시켜두었어요.\n\n## 결론\n\n이 과정을 통해 MSW와 MSW를 활용한 Toolbar 도입에 성공할 수 있었어요.\n\nMSW를 통한 API 모킹은 API 경로를 기반으로 이루어지므로, 각 요청을 명확하게 식별하고 관리할 수 있었어요.\n\nMSW Toolbar는 네트워크 요청의 시뮬레이션 과정을 간소화해주는데 큰 도움을 주었어요. 기존에는 네트워크 상태를 모니터링하고 조정하기 위해 크롬의 개발자 도구에 의존했지만, 이제는 Toolbar를 통해 직접적으로 응답 시간을 조절하거나 특정 API 요청에서 에러 상태를 유발하는 등의 작업을 쉽게 처리할 수 있게 되었어요. 이에 따라 다양한 네트워크 환경과 에러 상황을 빠르게 시뮬레이션하고 대응할 수 있을 것으로 기대하고 있어요.\n\n이를 통해 개발 과정에서의 시행착오를 줄이고, 개발 효율성을 높여가며, 최종적으로 사용자에게 더 나은 서비스를 제공하는 그로잉 팀이 되어볼게요. 감사합니다 :)\n"},{"excerpt":"mocking에 대해 알아보자 1. mocking 이란? 모킹은 특정 객체의 실제 구현 대신 가짜 객체를 사용해서 그 객체의 행동을 모방하는 프로세스입니다. 이러한 가짜 객체를 'mock 객체'라고 해요. Mock 객체는 우리의 서비스가 의존하고 있는 외부 시스템이나 복잡한 로직 없이도 동작할 수 있도록 해줍니다. 예를 들어, 서비스에서 사용하고 있는 실…","fields":{"slug":"/msw/"},"frontmatter":{"date":"February 24, 2024","title":"MSW로 mocking을 해보자 ","tags":["growing","msw","mocking"]},"rawMarkdownBody":"\n## mocking에 대해 알아보자\n\n### **1. mocking 이란?**\n\n**모킹**은 특정 객체의 실제 구현 대신 가짜 객체를 사용해서 그 객체의 행동을 모방하는 프로세스입니다. 이러한 가짜 객체를 'mock 객체'라고 해요. Mock 객체는 우리의 서비스가 의존하고 있는 외부 시스템이나 복잡한 로직 없이도 동작할 수 있도록 해줍니다. 예를 들어, 서비스에서 사용하고 있는 실제 DB를 거치지 않고 가짜 데이터를 사용하는 것입니다.\n\n### **2. mocking의 이점**\n\n그럼 어떤 이점이 있길래 mocking을 하는 걸까요? mocking의 장점을 3가지로 정리해볼 수 있어요.\n\n1. **외부 서비스나 리소스에 대한 의존성 제거**\n\n   → 외부 API나 데이터베이스와 같은 외부 서비스, 네트워크 지연 등에 영향을 받지 않고 테스트를 수행할 수 있습니다.\n\n2. **어려운 조건과 상황의 시뮬레이션**\n\n   → 네트워크 오류나 데이터베이스 연결 오류 등과 같은 예외 상황이나 희귀한 상황을 임의로 재현해서 특정 상황에서 애플리케이션이 어떻게 동작하는 지 테스트할 수 있습니다.\n\n3. **비용 절감**\n\n   → 테스트를 할 때 실제 서버를 이용하면 서버 비용이 부담이 될 수 있어요. 하지만 mocking을 통해 수행하면 실제 리소스를 사용하지 않으므로 테스트 비용을 절감할 수 있습니다.\n\n### **3. 우리가 모킹을 결정한 이유**\n\n그렇다면 그로잉 프로젝트에서 서버 데이터를 모킹 하기로 한 이유는 무엇일까요?\n\n저희는 비용 문제로 인해 서버를 계속 켜놓을 수 없었어요. 그리고 각 기능별로 에러와 로딩 상황에 대한 UI를 수정할 예정이라 이런 상황들을 빠르게 재현하고 적절히 처리하는데 mocking의 도움을 받으면 좋겠다는 생각을 했어요. 마지막으로, 후에 테스트 코드를 작성할 때 mocking 데이터를 재활용할 수 있다는 점도 저희의 결정에 영향을 줬습니다.\n\n## mocking 도구 비교 분석\n\n### 다른 라이브러리 소개\n\n- **Nock**\n  - Node.js 환경에서 HTTP 요청을 mocking하고, 테스팅할 수 있는 강력한 라이브러리에요. 주로 서버 사이드에서 API 호출을 가로채고 대체 응답을 제공하는 데 사용됩니다.\n- **Mirage JS**\n  - 백엔드 없이도 클라이언트 사이드에서 API를 모의할 수 있게 해주는 라이브러리에요. Mirage는 자체 ORM과 라우터를 제공하여 실제 백엔드 서버를 흉내낼 수 있습니다.\n- **JSON Server**\n  - 간단한 REST API를 빠르게 프로토타이핑하고자 할 때 유용한 툴로, JSON 파일을 데이터베이스로 사용하여 실제 서버처럼 작동하는 가짜 API 서버를 생성할 수 있습니다.\n\n### 라이브러리 비교\n\n1. **API support**\n\n   |               | MSW | Nock | Mirage                            | JSON server |\n   | ------------- | --- | ---- | --------------------------------- | ----------- |\n   | REST API      | ✅  | ✅   | ✅                                | ✅          |\n   | GraphQL API   | ✅  | ⛔   | 부분 지원(써드파티 애드온을 통해) | ⛔          |\n   | WebSocket API | ⛔  | ⛔   | ⛔                                | ⛔          |\n\n2. **Supported environment**\n\n   |         | MSW | Nock | Mirage                                                                             | JSON server                                  |\n   | ------- | --- | ---- | ---------------------------------------------------------------------------------- | -------------------------------------------- |\n   | Node.js | ✅  | ✅   | 부분 지원(주로 프런트엔드 위주, Node.js는 Mirage의 서버 사이드 렌더링 지원을 통해) | ✅                                           |\n   | Browser | ✅  | ⛔   | ✅                                                                                 | ⛔ (프록시 서버를 통해 간접적으로 사용 가능) |\n\n### **MSW만의 특징**\n\nMSW(Mock Service Worker)를 다른 mocking 도구들과 비교하여 채택한 주요 이유는 다음과 같아요.\n\n- **실제 네트워크 환경과의 유사성**\n  - MSW는 서비스 워커를 사용하여 실제 네트워크 요청을 가로채고 모의 응답을 제공해요. 이 접근 방식은 개발자가 실제 백엔드와 통신하는 것처럼 코드를 작성할 수 있게 하며, 나중에 실제 API로의 전환을 매끄럽게 해줘요. 다른 도구들이 라이브러리 레벨에서 모의를 제공하는 것과는 대조적으로, MSW는 네트워크 레벨에서 작동하므로 개발 경험이 더욱 실제 서버와 유시헤요.\n- **광범위한 테스트 및 개발 환경 지원**\n  - MSW는 브라우저 뿐만 아니라 Node.js 환경에서도 작동해요. 또한 Jest와 같은 단위 테스트 프레임워크뿐만 아니라 Cypress, Storybook과 같은 통합 테스트 및 UI 컴포넌트 테스트 환경에서도 사용할 수 있어요. 이는 하나의 모의 설정을 통해 여러 테스팅 환경과 개발 환경에서 일관된 API mocking을 가능하게 도와줍니다.\n\n## 초기 세팅을 해보아요.\n\n우선 사용자 데이터를 불러오는 간단한 API를 MSW를 사용해 연동해볼게요.\n\n### **1. 핸들러 작성하기**\n\n먼저, API 요청을 가로챌 핸들러를 작성해야 합니다.\n\n```tsx\n// handlers.ts\nimport { http, HttpResponse, delay } from \"msw\"\n\nexport const handlers = [\n  http.get<GetUserParams, null, UserDto, \"/user/:userId\">(\n    \"/user/:userId\",\n    async ({ params }) => {\n      const { userId } = params\n\n      await delay(1000)\n\n      return HttpResponse.json({\n        id: userId,\n        nickName: \"곰곰곰\",\n        birthDay: \"2000-01-01\",\n        anniversaryDay: \"2023-12-16\",\n      })\n    }\n  ),\n]\n```\n\n> HttpResponse 대신 new Response(..) 를 사용할 수도 있지만, HttpResponse가 1) json(),formData() 같은 유용한 메서드를 지원해주고 2) set-cookie를 설정할 수도 있어서 HttpResponse를 사용했어요.\n\n### **2. 브라우저 환경과 통합하기**\n\nMSW를 웹 애플리케이션과 통합하기 위해서는 몇 가지 단계를 더 거쳐야 해요.\n\n1. **Worker script 설치**\n\n   아래 명령어를 실행합니다.\n\n   ```powershell\n   npx msw init ./public --save\n   ```\n\n2. **Worker 설정**\n\n   MSW Worker를 설정하고 핸들러를 등록합니다.\n\n   ```tsx\n   // browser.ts\n   import { setupWorker } from \"msw/browser\"\n   import { handlers } from \"./handlers\"\n\n   export const worker = setupWorker(...handlers)\n   ```\n\n3. **Worker 등록 및 실행**\n\n   개발 환경에서만 MSW를 활성화하기 위해 조건을 설정하고, 애플리케이션 실행 전에 Worker를 등록합니다.\n\n   ```tsx\n   // msw.ts\n   const enableMocking = async () => {\n     if (process.env.NODE_ENV !== \"development\") {\n       return\n     }\n\n     const { worker } = await import(\"./mocks/browser\")\n\n     return worker.start()\n   }\n\n   // index.tsx\n   const root = ReactDOM.createRoot(document.getElementById(\"root\"))\n   enableMocking().then(() => {\n     root\n       .render\n       // 애플리케이션 컴포넌트\n       ()\n   })\n   ```\n\n### **3. 콘솔에서 확인하기**\n\n애플리케이션을 실행한 후, 개발자 도구의 콘솔에서 MSW가 정상적으로 작동하는지 확인합니다.\n\n![](console-1-image.png)\n\n잘 작동하네요! 😮😮\n\n### **4. Mocking하지 않은 API 처리하기**\n\n그런데 콘솔에는 많은 경고가 존재하고 있었어요.\n\n![](console-2-image.png)\n\n이를 알아본 결과, MSW는 정의되지 않은 API 요청을 모두 캐치해 경고를 출력한다고 해요.\n\n<div align='center'>\n    <img src='console-3-image.png' width='300px' />\n</div>\n\n따라서 onUnhandledRequest 옵션을 bypass로 설정하여 정의되지 않은 API 요청은 무시하도록 설정했어요.\n\n```tsx\nworker.start({ onUnhandledRequest: \"bypass\" })\n```\n\n## 폴더 구조를 잡아봅시다.\n\n간단하게 테스트해 본 결과, msw도입을 위해 필요한 파일들은 크게 3가지 종류로 나눌 수 있었어요.\n\n1. API 핸들러\n2. Mock 데이터\n3. 브라우저 환경에서 실행할 수 있게 도와주는 Worker함수\n\n따라서 각 파일들을 어떤 디렉터리에 위치시킬지 생각해보았어요.\n\n### 방법 1: API 경로 기반 구조\n\n첫번째로 고려한 방식은 API 주소를 기준으로 폴더를 구성하는 방식이에요.\n\n예를 들어 `http://localhost/test/verification`이라는 API를 Mocking한다고 했을 때, 파일구조는 아래와 같이 작성됩니다.\n\n```\nsrc\n├── __mocks__/\n│   ├── localhost/\n│   │   └── test/\n│   │       └── verification\n│   ├── handlers.ts\n│   └── browser.ts\n```\n\n**장점은 다음과 같아요.**\n\n- **직관적인 경로:** API 경로를 기반으로 하는 구조는 파일 시스템에서 해당 API를 쉽게 찾을 수 있게 해줍니다. 이는 특히 큰 프로젝트에서 API를 빠르게 찾아 수정해야 할 때 유용해요.\n- **변경 관리 용이:** 특정 API에 대한 변경 사항이 있을 때, 관련 파일을 찾아 수정하기가 간편합니다.\n\n**단점은 다음과 같아요.**\n\n- **중복된 구조:** 여러 API가 비슷한 데이터 구조를 공유할 경우, 코드와 mock 데이터의 중복이 발생할 수 있습니다.\n- **스케일링 문제:** 프로젝트 규모가 커지면 폴더 구조가 깊어지고 복잡해질 수 있습니다.\n\n### 방법 2: Mock 데이터 중심 구조\n\n두번째로 고려해 본 방식은 Mock 데이터만 별도로 관리하고 핸들러는 한 곳에 모으는 방식입니다.\n\n```\nsrc\n├── server/\n│   ├── __mocks__/\n│   │   └── userList.ts/\n│   ├── handlers.ts\n│   └── browser.ts\n```\n\n**장점은 다음과 같아요.**\n\n- **데이터 중심:** 공통된 데이터 구조를 사용하는 API들이 많은 경우, mock 데이터를 중앙에서 관리함으로써 중복을 줄일 수 있습니다.\n- **유연성:** 데이터 변경이 필요할 때 한 곳에서 관리하기 때문에, 데이터의 일관성을 유지하기가 용이합니다.\n\n**단점은 다음과 같아요.**\n\n- **핸들러 관리:** 모든 핸들러를 한 곳에 모으게 되면, 파일이 방대해지고 관리가 어려워질 수 있습니다.\n- **데이터와 핸들러의 분리:** 데이터와 핸들러가 분리되어 있어, 관련 핸들러와 데이터 사이의 연결을 파악하기 어려울 수 있습니다.\n\n### 방법 3: 도메인별 구조\n\n세번째로 고려한 방식은 도메인별로 핸들러와 데이터를 모아두는 방식이에요.\n\n```\nsrc\n├── mocks/\n│   ├── domain/\n│   │   └── album/\n│   │       ├── data.ts\n│   │       └── handlers.ts\n│   ├── handlers.ts\n│   └── browser.ts\n```\n\n**장점은 다음과 같아요.**\n\n- **도메인 중심:** 서비스의 기능별로 구분되어 있어, 관련 기능을 개발할 때 모든 관련 파일을 쉽게 찾을 수 있습니다.\n- **유지보수 용이:** 각 도메인별로 핸들러와 데이터를 분리함으로써, 유지보수가 용이합니다. 특정 기능에 문제가 생겼을 때, 해당 도메인의 폴더만 확인하면 됩니다.\n- **확장성:** 새로운 기능이나 도메인이 추가될 때, 새로운 폴더를 만들어 그 안에 모든 관련 파일을 배치함으로써 확장성이 높습니다.\n\n**단점은 다음과 같아요.**\n\n- **공통 데이터 관리:** 여러 도메인에서 공통적으로 사용되는 데이터가 있을 경우, 이를 어떻게 관리할지 고민이 필요합니다.\n- **API 간 데이터 공유의 어려움:** 특정 도메인에서만 사용되는 데이터가 아닌, 전역적으로 사용되는 데이터의 경우, 어느 도메인에 속해야 할지 결정하기 어려울 수 있습니다.\n\n### 그로잉은요?\n\n그로잉 서비스는 각 기능별로 구분된 도메인이 명확하기 때문에, 3번 방식이 가장 적합하다고 판단했어요.\n\n그리고 기존에 외부 라이브러리는 libs폴더에 정의해두고 사용했지만, msw 관련 파일은 mocks폴더에 전부 모아두기로 했어요. 빌드시 필요없는 코드와 파일들을 한 곳에 몰아넣기 위함이에요.\n\n또한 3번 방식처럼 도메인별 핸들러 함수를 한 파일에 전부 정의해두는 것보다는 분리한 후 index 파일에서 취합해서 내보내기로 했어요. API별 데이터들과 params, 200일때, 400일때 케이스들을 한 파일에 모두 작성하면 코드의 길이가 너무 길어져서 가독성을 해칠 것이라고 판단했기 때문이에요.\n\n따라서 아래와 같이 폴더 구조를 정할 수 있었어요.\n\n```\nsrc\n├── mocks/\n│   ├── user/\n│   │   ├── index.ts\n│   │   ├── getUserHandler.ts\n│   │   └── anotherHandler.ts\n│   ├── handlers.ts // 도메인별 핸들러 함수를 모두 취합하는 곳이에요.\n│   ├── browser.ts // worker를 정의해 둔 파일이에요.\n│   └── msw.ts // enableMocking() 함수를 정의해 둔 파일이에요.\n```\n\n아래는 예시입니다.\n\n```tsx\n// mocks/user/getUserHandler.ts\ntype Params = {\n  userId: string\n}\n\nconst data: UserDto = {\n  id: \"1\",\n  nickName: \"곰곰곰\",\n  birthDay: \"2000-01-01\",\n  anniversaryDay: \"2023-12-16\",\n}\n\nexport const getUserHandler = () => {\n  http.get<Params, null, UserDto, \"/user/:userId\">(\n    \"/user/:userId\",\n    async ({ params }) => {\n      const { userId } = params\n\n      await delay(1000)\n\n      return HttpResponse.json(data)\n    }\n  )\n}\n\n// mocks/user/index.ts\nimport { getUserHandler } from \"./getUserHandler\"\nimport { anotherHandler } from \"./anotherHandler\"\n\nexport const UserHandlers = [getUserHandler, anotherHandler]\n```\n\n그러나 이 방식은 일부 도메인에는 적용할 수 없었어요.\n\nGET, POST, DELETE 하는 API 가 같은 데이터를 바라봐야 했기 때문이죠. 만약 기존 데이터를 DELETE 요청으로 지운 후에 GET 요청을 했을 때, 지운 데이터가 남아 있다면 테스트할 때 불편하다고 판단했어요.\n\n### 최최최최종.jpg\n\n따라서 데이터를 공유해야하는 API 들은 한 파일 안에 작성해두는 것으로 변경했어요.\n\n```\nsrc\n├── mocks/\n│   ├── user/\n│   │   ├── getUserHandler.ts // 데이터를 공유할 필요없는 API\n│   │   ├── ...\n│   │   └── index.ts\n│   ├── chat/\n│   │   ├── data/\n│   │   │   ├── chatData.ts // 공유할 데이터\n│   │   │   └── image.png\n│   │   ├── chatHandler.ts // 공유할 데이터들을 사용하는 API들\n│   │   ├── chatQuestionHandler.ts\n│   │   └── index.ts\n│   ├── handlers.ts\n│   └── browser.ts\n```\n\n## 에러 응답 목업은 어떻게 하지? 🤔\n\n애플리케이션은 완벽할 수 없습니다. 네트워크 에러나 우리가 미처 처리하지 못한 예외 등으로 인해 생각한 대로 동작하지 않기도 해요. 그렇기 때문에 성공적인 응답만 mocking하는 것으로는 부족합니다. 이번 절에서는 에러 응답에 대한 모킹 방법에 대해 알아볼게요.\n\n### MSW 공식 문서 살펴보기\n\nMSW의 공식 문서에서 다음과 같은 에러 응답 목업 방식에 대해 찾을 수 있었어요.\n\n- status code 설정하기\n\n  ```jsx\n  export const handlers = [\n    http.delete(\"/posts/:id\", ({ params }) => {\n      const { id } = params\n      const deletedPost = allPosts.get(id)\n\n      if (!deletedPost) {\n        return new HttpResponse(null, { status: 404 })\n      }\n\n      allPosts.delete(id)\n\n      return HttpResponse.json(deletedPost)\n    }),\n  ]\n  ```\n\n  → 조건에 따라 에러를 나타내는 status를 함께 반환하는 방식이에요.\n\n- Network Error\n\n  ```jsx\n  import { http, HttpResponse } from \"msw\"\n\n  export const handlers = [\n    http.get(\"/resource\", () => {\n      return HttpResponse.error()\n    }),\n  ]\n  ```\n\n  → 네트워크 에러의 경우 위와 같이 HttpResponse.error()를 반환해요.\n\n- dynamic mock scenarios\n\n  ```jsx\n  import { http, HttpResponse } from \"msw\"\n\n  export const scenarios = {\n    success: [\n      http.get(\"/user\", () => {\n        return HttpResponse.json({ name: \"minju\" })\n      }),\n    ],\n    error: [\n      http.get(\"/user\", () => {\n        return new HttpResponse(null, { status: 500 })\n      }),\n    ],\n  }\n  ```\n\n  → 응답에 성공하는 경우와, 에러인 경우를 시나리오로 작성할 수 있어요. url 뒤에 `?scenario=error` 을 붙이면 오류 응답을 반환하는 경우에 어떻게 작동하는지 런타임에서 확인할 수 있어요.\n\n### 그로잉에서 선택한 에러 목업\n\n저희는 런타임에서 여러 기능들의 성공과 실패의 조합에 따라 테스트를 할 수 있는 방식이 필요했어요. msw에서 제공해주는 dynamic mock scenarios를 사용해 이를 구현하려면 url이 바뀌여야 하고, 한 페이지에 있는 여러 기능에 대해 각 시나리오를 식별하도록 코드를 추가로 작성해야 합니다. 그래서 저희는 status code를 런타임에 다르게 설정하는 방식을 사용하기로 했고, 여러 조합을 편하게 테스트할 수 있게 도와주는 툴바를 제작하기로 했어요.\n\n<br />\n\n> 🤔 어떻게 MSW Toolbar를 만들었는지 궁금하다면? ➡️ [다음글에서 계속](https://teamgrowing.github.io/team-blog/msw-toolbar)\n"},{"excerpt":"안녕하세요. 그로잉 FE팀입니다! 😀 현재, 저희는 그로잉 프로젝트 리팩토링을 앞두고 있어요. 작성한지 1-2년 된 코드였기에 본격적인 리팩토링을 시작하기 전, 사용하지 않는 파일들을 정리하고 폴더 구조를 다듬을 필요가 있었어요. 프로젝트의 폴더 구조를 잘 정의하는 것은 앞으로의 개발 효율성에 영향을 주는 중요한 요소이기도 하죠. 순간의 선택이 10년을 …","fields":{"slug":"/folder-structure/"},"frontmatter":{"date":"February 23, 2024","title":"행복한 개발을 위한 폴더 구조는?","tags":["growing","folder-structure"]},"rawMarkdownBody":"\n![출처: 추억의 금성사 월페이퍼 디자인 by.비범한츈](main-image.png)\n\n안녕하세요. 그로잉 FE팀입니다! 😀\n\n현재, 저희는 그로잉 프로젝트 리팩토링을 앞두고 있어요.\n\n작성한지 1-2년 된 코드였기에 본격적인 리팩토링을 시작하기 전, 사용하지 않는 파일들을 정리하고 폴더 구조를 다듬을 필요가 있었어요. 프로젝트의 폴더 구조를 잘 정의하는 것은 앞으로의 개발 효율성에 영향을 주는 중요한 요소이기도 하죠. 순간의 선택이 10년을 좌우한다는 말이 있듯, 앞으로의 리팩토링 효율성을 좌우할 폴더 구조를 어떻게 개편했을까요?\n\n저희가 파악한 그로잉 프로젝트의 폴더 구조의 문제점은 총 4가지가 있었어요.\n\n## 문제점 1: 폴더의 이름과 역할의 모호함\n\n첫번째로 발견한 문제점은 폴더의 이름과 이에 따른 역할이 불분명하다는 것입니다. 폴더의 이름과 폴더 내부 파일의 역할이 잘 맞게 개선하기 위해 다음과 같이 폴더 구조를 변경했어요.\n\n### 1. services, util → apis, libs, utils\n\n저희가 기존에 정의했던 폴더 구조에는 services폴더가 있었어요. services에는 비즈니스 로직을 모아두기로 했는데, 비즈니스 로직의 범위가 애매해 api들을 정의해두는 곳으로 사용했어요. 그리고 라이브러리와 관련된 코드, 프로젝트의 여러 곳에서 재사용되는 간단한 함수 등은 util폴더에 넣었습니다.\n\n**한 폴더에 여러 역할의 파일들이 들어가 있다는 문제**를 해결하기 위해 services와 utils폴더를 apis, libs, utils 총 3개의 폴더로 분리하기로 결정했어요.\n\n- **apis**\n  ![](apis-image.png)\n\n  백엔드 서버에 요청을 보내기 위한 api를 저장하기 위한 폴더입니다. 데이터와 관련된 요청을 위한 로직만 모여있기 때문에 services라는 이름 보다 apis가 더 적절하다고 생각해 이름을 변경했어요.\n\n- **libs**\n  ![](libs-image.png)\n\n  외부 라이브러리와 관련된 파일들을 모아두기 위한 폴더입니다. text 가공을 위한 로직, 비디오를 다루기 위한 로직 등이 담겨있어요.\n\n- **utils**\n  ![](utils-image.png)\n\n  그 외 프로젝트 전반에서 사용되는 잡다한 코드들을 위한 폴더입니다. 그로잉 프로젝트에서 사용하고 있는 react-query, dayjs, react-hook-form 등의 라이브러리를 사용하는 데 필요한 로직들이 담겨있어요.\n\n### 2. types → models\n\n기존의 폴더구조에서는 types라는 폴더에 dto, 컴포넌트에서 필요한 각종 type들, 스타일에 필요한 type들이 모두 섞여있어 원하는 파일을 찾기 어렵다는 문제가 있었습니다. 이를 해결하기 위해 models 폴더를 따로 만들어 파일들을 역할에 따라 분리했어요.\n\n- **models**\n  ![](models-image.png)\n\n  기존에는 `types/chat/` 폴더의 하위에 `chatLine.dto.ts`, `chat.dto.ts` 등으로 하나의 dto를 하나의 파일에 작성했었는데 이를 기능에 따라 그룹화해 `models/` 에 위치 시켰습니다. 이렇게 하면, 한 파일로 여러 dto들을 모아 두면 다른 파일에서 dto를 import할 때 import문이 간략해진다는 장점이 있어요. 그리고 models 에는 백엔드와의 데이터 교환을 도와주는 dto들을 모아두었습니다.\n\n- **types**\n  ![](types-image.png)\n  dto 외의 font, style을 위한 타입들을 위한 폴더입니다.\n\n위와 같이 세부적으로 폴더를 분리해 로직의 역할에 따라 파일들을 분류할 수 있었습니다. 사실 dto 파일들은 api와 관련된 파일들이기 때문에 apis폴더 안에 위치시키는 것이 좋을 지에 대한 고민이 있었어요. 하지만 정의된 dto들이 apis폴더에 있는 파일 뿐 아니라 react-query를 위한 쿼리들이나 컴포넌트 파일에서도 사용되기 때문에 `src/models` 폴더에 위치시키기로 했습니다.\n\n## 문제점 2: 컴포넌트 파일 내 스타일 코드 혼재\n\n두번째로는 컴포넌트 파일 내에 스타일 관련 코드가 혼재되어 있어서, 파일의 복잡성이 증가하고 가독성이 떨어지는 문제점이 있었어요.\n\n```tsx\nconst Title = styled.div`\n  width: 100%;\n  font-family: 'PretendardBold';\n  font-size: 17px;\n  color: ${({ theme }) => theme.color.gray50};\n  text-align: center;\n`;\nconst Description = styled.div`\n  width: 100%;\n  font-size: 14px;\n  color: ${({ theme }) => theme.color.gray50};\n  text-align: center;\n  white-space: pre-wrap;\n  word-break: break-all;\n`;\nconst Buttons = styled.div`\n  width: 100%;\n  border-top: 0.5px solid ${({ theme }) => theme.color.gray50}50;\n  display: flex;\n`;\n\nexport default function Modal({\n  onModal,\n  setOnModal,\n\t...\n}: ModalProps) {\n  if (!onModal) {\n    return null;\n  }\n\n  return (\n    <ModalPortal>\n      <Overlay />\n      <Wrapper>\n        <Main>\n          {title && <Title className=\"text-ellipsis\">{title}</Title>}\n          {description && <Description>{description}</Description>}\n        </Main>\n        <Buttons>\n\t\t\t   {/* */}\n        </Buttons>\n      </Wrapper>\n    </ModalPortal>\n  );\n}\n```\n\n따라서 스타일 파일을 따로 분리하기로 결정했어요.\n\n```tsx\nsrc\n└── components\n    └── Header\n        ├── Header.tsx  // 컴포넌트 로직 파일\n        └── Header.styled.ts  // 스타일 파일\n```\n\n사용할 때는 해당 스타일을 사용하는 컴포넌트 파일에서 스타일을 import하여 사용합니다.\n\n```tsx\n// Header.tsx\nimport S from './Header.styles';\n\nconst Header = () => {\n  return (\n    <S.HeaderContainer>\n      <S.Logo>그로잉</Logo>\n      {/* 나머지 컴포넌트 내용 */}\n    </S.HeaderContainer>\n  );\n};\n\nexport default Header;\n```\n\n이를 통해 스타일과 컴포넌트 로직의 분리를 더욱 명확히 할 수 있었고, 스타일 변경 시 해당 스타일 파일만 수정하면 되므로 유지보수성이 향상되는 효과도 얻을 수 있었어요.\n\n## 문제점 3 : 응집도 부족\n\n기존의 폴더구조에서는 `src/components/pages/` 형태로 페이지 별로 컴포넌트를 분리했고 `src/pages`에는 페이지 컴포넌트만 있었어요. 예를 들어, `src/components/gallery/` 에 있는 컴포넌트들을 사용해 `src/pages/GalleryPage.tsx` 를 구성하는 방식이에요.\n\n이 경우에는 페이지를 기준으로 폴더를 나누기 때문에 components폴더 처럼 다른 폴더들에서도 페이지별 폴더가 필요했어요. (ex. `components/gallery`, `hooks/gallery`). 그렇다보니 컴포넌트의 이름이 바뀌면 이와 관련된 파일이 이곳저곳에 분산 되어 있어 수정하기 번거롭다는 문제가 생겼어요.\n\n그래서 저희는 파일 유형에 따라 분류를 했던 폴더 구조에서 도메인(기능)에 따라 분류를 하는 폴더 구조로 전환했습니다.\n\n- components 폴더에는 프로젝트에서 공통으로 사용할 컴포넌트를 모아둡니다.\n  ![](components-image.png)\n\n- 도메인별 페이지, 해당 도메인 내에서 사용되는 컴포넌트와 훅들은 모두 pages에 모아둡니다.\n\n  <img src='login-image.png' width='200px'/>\n\n위와 같이 폴더 구조를 변경한 후, 각 기능별 페이지 폴더 안에 필요한 파일들이 들어있는 형태가 되어 도메인별로 응집도를 높일 수 있었어요.\n\n## 문제점 4: 베럴 파일 적용\n\n현재 그로잉 프로젝트에는 모듈 import문이 복잡하다는 문제가 있었어요.\n\n```tsx\n// 단일 컴포넌트 직접 임포트\nimport Modal from \"components/common/Modal/Modal\"\nimport AlbumModal from \"components/common/AlbumModal/AlbumModal\"\n```\n\n이러한 모듈 import의 복잡성을 줄이기 위해 베럴 파일을 도입하는 것 전략을 고려하게 되었습니다.\n\n아래와 같이 베럴 파일을 도입한다면 여러 하위 모듈을 한 곳에서 관리함으로써, 임포트 경로를 간소화하고 코드의 가독성을 향상시킬 수 있어요.\n\n```tsx\n// src/components/common/index.ts\nexport { default as Modal } from \"./Modal\"\nexport { default as AlbumModal } from \"./AlbumModal\"\n\n// 사용하는 곳.tsx\nimport { Modal, AlbumModal } from \"components/common\" // 간단\n```\n\n그러나 베럴 파일 사용에는 몇 가지 고려해야 할 사항이 있다고 해요. 특히, 대규모 프로젝트의 경우 다음과 같은 이유로 주의가 필요합니다.\n\n1. **트리 쉐이킹(Tree Shaking) 최적화**\n\n   웹팩(Webpack)과 같은 모듈 번들러는 사용되지 않는 코드를 제거하는 트리 쉐이킹 과정을 통해 최종 번들의 크기를 줄입니다. 베럴 파일을 통해 모든 모듈을 임포트하면, 실제로 사용되지 않는 모듈까지 번들에 포함될 가능성이 있어 트리 쉐이킹의 효율성이 떨어질 수 있습니다.\n\n2. **코드 스플리팅(Code Splitting) 최적화**\n\n   베럴 파일을 사용하면, 필요한 컴포넌트만을 로드하는 대신 관련된 모든 컴포넌트가 함께 로드될 수 있습니다. 이는 초기 로딩 시간에 부정적인 영향을 줄 수 있으며, 특히 대규모 애플리케이션에서는 성능 저하의 원인이 될 수 있습니다.\n\n이러한 이유로, 베럴 파일의 사용을 재고하고 프로젝트의 현재 방식을 유지하기로 결정했어요.\n\n## 결론\n\n결론적으로, 그로잉 프로젝트의 폴더구조는 이렇게 바뀌었답니다!\n\n**😠 변경 이전의 폴더 구조**\n\n```jsx\n.storybook // Storybook 설정 폴더\n\npublic // 이미지, 아이콘 등\n\nsrc\n ├── assets\n │   ├── fonts\n │   ├── icons\n │   └── image\n │\n ├── components\n │   │   └─common // 공통으로 사용되는 컴포넌트\n │   │\n │   ├── pages // 페이지별 컴포넌트 모음\n │   │   ├── main // 메인 화면\n │   │   │\t ├─ Banner.tsx\n │   │   │   └─ ContentsTile.tsx\n │   │   │\n │   │   ├── contents // 콘텐츠 화면\n │   │   │\t ├─ Banner.tsx\n │   │   │   └─ ContentsTile.tsx\n │\n ├── constants\n ├── hooks\n ├── pages\n │   ├─ Main.tsx\n │   ├─ ContentsHome.tsx\n │   └─ ...\n │\n ├── services\n ├── styles\n ├── types\n ├── util\n ├── stores\n │\n ├── App.tsx\n ├── index.tsx\n └── index.css\n\n.babelrc\n.eslintrc\n.gitignore\n.prettierrc\npakage.json\nREADME.md\n.tsconfig.json\nyarn.lock\n```\n\n**😊 변경된 폴더 구조**\n\n```jsx\n.storybook\npublic\n\nsrc\n├─apis // 백엔드 서비스와 상호작용을 위한 API 함수들\n├─assets\n│  ├─fonts\n│  ├─icons\n│  └─image\n├─components // 재사용 가능한 UI 컴포넌트들\n│  ├─common // 애플리케이션 전반에 걸쳐 사용되는 일반 컴포넌트들 (버튼, 입력창 등)\n│  └─layout // 애플리케이션의 레이아웃과 관련된 컴포넌트들 (헤더, 푸터, 사이드바 등)\n│\n├─constants\n├─hooks // 컴포넌트 간에 공유되는 로직을 위한 커스텀 React 훅\n├─libs // 프로젝트 내에서 쉽게 사용할 수 있도록 외부 라이브러리를 감싸는 라이브러리나 유틸리티들\n├─mocks // 테스팅 및 개발을 위한 모의 데이터와 함수들\n├─models // 비즈니스 엔티티와 관련된 데이터 모델과 타입, 주로 TypeScript 타입 정의\n├─pages\n│  ├─calendar\n│  │  ├─CalendarPage // 캘린더 페이지를 위한 메인 컴포넌트\n│  │  └─components // 캘린더 기능과 관련된 하위 컴포넌트들\n│  │      ├─...\n│  ├─chat\n│  ├─gallery\n│  ├─home\n│  ├─login\n│  └─more\n├─stores\n├─styles\n├─types // 비즈니스 모델과 직접적으로 관련되지 않은 TypeScript 타입 정의들\n└─utils // 애플리케이션 전반에 걸쳐 공통적으로 사용되는 유틸리티 함수들 (포맷팅, 검증 등)\n\n.babelrc\n.eslintrc\n.gitignore\n.prettierrc\npakage.json\nREADME.md\n.tsconfig.json\nyarn.lock\n\n```\n\n폴더 구조에는 하나의 정답이 있는 것이 아니라, 일관성을 유지하고, 팀 내에서 모두가 이해하고 따를 수 있는 명확한 규칙을 설정한다는 것에 의미가 있다고 생각해요. 그러므로 프로젝트의 규모, 팀의 작업 스타일, 그리고 향후 유지보수와 확장 계획 등을 고려해 자신의 프로젝트에 맞는 폴더 구조를 구성하는 것이 중요한 것 같습니다.\n\n## Reference\n\n- https://github.com/yeonjuan/dev-blog/blob/master/JavaScript/speeding-up-the-javascript-ecosystem-the-barrel-file-debacle.md\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}