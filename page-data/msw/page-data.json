{"componentChunkName":"component---src-templates-post-jsx","path":"/msw/","result":{"data":{"site":{"siteMetadata":{"title":"Team Growing"}},"markdownRemark":{"id":"4f66afb8-7a6a-512e-9059-cb8944da2816","excerpt":"mocking에 대해 알아보자 1. mocking 이란? 모킹은 특정 객체의 실제 구현 대신 가짜 객체를 사용해서 그 객체의 행동을 모방하는 프로세스입니다. 이러한 가짜 객체를 'mock 객체'라고 해요. Mock 객체는 우리의 서비스가 의존하고 있는 외부 시스템이나 복잡한 로직 없이도 동작할 수 있도록 해줍니다. 예를 들어, 서비스에서 사용하고 있는 실…","html":"<h2>mocking에 대해 알아보자</h2>\n<h3><strong>1. mocking 이란?</strong></h3>\n<p><strong>모킹</strong>은 특정 객체의 실제 구현 대신 가짜 객체를 사용해서 그 객체의 행동을 모방하는 프로세스입니다. 이러한 가짜 객체를 'mock 객체'라고 해요. Mock 객체는 우리의 서비스가 의존하고 있는 외부 시스템이나 복잡한 로직 없이도 동작할 수 있도록 해줍니다. 예를 들어, 서비스에서 사용하고 있는 실제 DB를 거치지 않고 가짜 데이터를 사용하는 것입니다.</p>\n<h3><strong>2. mocking의 이점</strong></h3>\n<p>그럼 어떤 이점이 있길래 mocking을 하는 걸까요? mocking의 장점을 3가지로 정리해볼 수 있어요.</p>\n<ol>\n<li>\n<p><strong>외부 서비스나 리소스에 대한 의존성 제거</strong></p>\n<p>→ 외부 API나 데이터베이스와 같은 외부 서비스, 네트워크 지연 등에 영향을 받지 않고 테스트를 수행할 수 있습니다.</p>\n</li>\n<li>\n<p><strong>어려운 조건과 상황의 시뮬레이션</strong></p>\n<p>→ 네트워크 오류나 데이터베이스 연결 오류 등과 같은 예외 상황이나 희귀한 상황을 임의로 재현해서 특정 상황에서 애플리케이션이 어떻게 동작하는 지 테스트할 수 있습니다.</p>\n</li>\n<li>\n<p><strong>비용 절감</strong></p>\n<p>→ 테스트를 할 때 실제 서버를 이용하면 서버 비용이 부담이 될 수 있어요. 하지만 mocking을 통해 수행하면 실제 리소스를 사용하지 않으므로 테스트 비용을 절감할 수 있습니다.</p>\n</li>\n</ol>\n<h3><strong>3. 우리가 모킹을 결정한 이유</strong></h3>\n<p>그렇다면 그로잉 프로젝트에서 서버 데이터를 모킹 하기로 한 이유는 무엇일까요?</p>\n<p>저희는 비용 문제로 인해 서버를 계속 켜놓을 수 없었어요. 그리고 각 기능별로 에러와 로딩 상황에 대한 UI를 수정할 예정이라 이런 상황들을 빠르게 재현하고 적절히 처리하는데 mocking의 도움을 받으면 좋겠다는 생각을 했어요. 마지막으로, 후에 테스트 코드를 작성할 때 mocking 데이터를 재활용할 수 있다는 점도 저희의 결정에 영향을 줬습니다.</p>\n<h2>mocking 도구 비교 분석</h2>\n<h3>다른 라이브러리 소개</h3>\n<ul>\n<li>\n<p><strong>Nock</strong></p>\n<ul>\n<li>Node.js 환경에서 HTTP 요청을 mocking하고, 테스팅할 수 있는 강력한 라이브러리에요. 주로 서버 사이드에서 API 호출을 가로채고 대체 응답을 제공하는 데 사용됩니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Mirage JS</strong></p>\n<ul>\n<li>백엔드 없이도 클라이언트 사이드에서 API를 모의할 수 있게 해주는 라이브러리에요. Mirage는 자체 ORM과 라우터를 제공하여 실제 백엔드 서버를 흉내낼 수 있습니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>JSON Server</strong></p>\n<ul>\n<li>간단한 REST API를 빠르게 프로토타이핑하고자 할 때 유용한 툴로, JSON 파일을 데이터베이스로 사용하여 실제 서버처럼 작동하는 가짜 API 서버를 생성할 수 있습니다.</li>\n</ul>\n</li>\n</ul>\n<h3>라이브러리 비교</h3>\n<ol>\n<li>\n<p><strong>API support</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MSW</th>\n<th>Nock</th>\n<th>Mirage</th>\n<th>JSON server</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>REST API</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>GraphQL API</td>\n<td>✅</td>\n<td>⛔</td>\n<td>부분 지원(써드파티 애드온을 통해)</td>\n<td>⛔</td>\n</tr>\n<tr>\n<td>WebSocket API</td>\n<td>⛔</td>\n<td>⛔</td>\n<td>⛔</td>\n<td>⛔</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>Supported environment</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MSW</th>\n<th>Nock</th>\n<th>Mirage</th>\n<th>JSON server</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Node.js</td>\n<td>✅</td>\n<td>✅</td>\n<td>부분 지원(주로 프런트엔드 위주, Node.js는 Mirage의 서버 사이드 렌더링 지원을 통해)</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Browser</td>\n<td>✅</td>\n<td>⛔</td>\n<td>✅</td>\n<td>⛔ (프록시 서버를 통해 간접적으로 사용 가능)</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n<h3><strong>MSW만의 특징</strong></h3>\n<p>MSW(Mock Service Worker)를 다른 mocking 도구들과 비교하여 채택한 주요 이유는 다음과 같아요.</p>\n<ul>\n<li>\n<p><strong>실제 네트워크 환경과의 유사성</strong></p>\n<ul>\n<li>MSW는 서비스 워커를 사용하여 실제 네트워크 요청을 가로채고 모의 응답을 제공해요. 이 접근 방식은 개발자가 실제 백엔드와 통신하는 것처럼 코드를 작성할 수 있게 하며, 나중에 실제 API로의 전환을 매끄럽게 해줘요. 다른 도구들이 라이브러리 레벨에서 모의를 제공하는 것과는 대조적으로, MSW는 네트워크 레벨에서 작동하므로 개발 경험이 더욱 실제 서버와 유시헤요.</li>\n</ul>\n</li>\n<li>\n<p><strong>광범위한 테스트 및 개발 환경 지원</strong></p>\n<ul>\n<li>MSW는 브라우저 뿐만 아니라 Node.js 환경에서도 작동해요. 또한 Jest와 같은 단위 테스트 프레임워크뿐만 아니라 Cypress, Storybook과 같은 통합 테스트 및 UI 컴포넌트 테스트 환경에서도 사용할 수 있어요. 이는 하나의 모의 설정을 통해 여러 테스팅 환경과 개발 환경에서 일관된 API mocking을 가능하게 도와줍니다.</li>\n</ul>\n</li>\n</ul>\n<h2>초기 세팅을 해보아요.</h2>\n<p>우선 사용자 데이터를 불러오는 간단한 API를 MSW를 사용해 연동해볼게요.</p>\n<h3><strong>1. 핸들러 작성하기</strong></h3>\n<p>먼저, API 요청을 가로챌 핸들러를 작성해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// handlers.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> http<span class=\"token punctuation\">,</span> HttpResponse<span class=\"token punctuation\">,</span> delay <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"msw\"</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> handlers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  http<span class=\"token punctuation\">.</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>GetUserParams<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> UserDto<span class=\"token punctuation\">,</span> <span class=\"token string\">\"/user/:userId\"</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"/user/:userId\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> params <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> params\n\n      <span class=\"token keyword\">await</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">return</span> HttpResponse<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        id<span class=\"token operator\">:</span> userId<span class=\"token punctuation\">,</span>\n        nickName<span class=\"token operator\">:</span> <span class=\"token string\">\"곰곰곰\"</span><span class=\"token punctuation\">,</span>\n        birthDay<span class=\"token operator\">:</span> <span class=\"token string\">\"2000-01-01\"</span><span class=\"token punctuation\">,</span>\n        anniversaryDay<span class=\"token operator\">:</span> <span class=\"token string\">\"2023-12-16\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<blockquote>\n<p>HttpResponse 대신 new Response(..) 를 사용할 수도 있지만, HttpResponse가 1) json(),formData() 같은 유용한 메서드를 지원해주고 2) set-cookie를 설정할 수도 있어서 HttpResponse를 사용했어요.</p>\n</blockquote>\n<h3><strong>2. 브라우저 환경과 통합하기</strong></h3>\n<p>MSW를 웹 애플리케이션과 통합하기 위해서는 몇 가지 단계를 더 거쳐야 해요.</p>\n<ol>\n<li>\n<p><strong>Worker script 설치</strong></p>\n<p>아래 명령어를 실행합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\">npx msw init <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>public <span class=\"token operator\">--</span>save</code></pre></div>\n</li>\n<li>\n<p><strong>Worker 설정</strong></p>\n<p>MSW Worker를 설정하고 핸들러를 등록합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// browser.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> setupWorker <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"msw/browser\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> handlers <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./handlers\"</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> worker <span class=\"token operator\">=</span> <span class=\"token function\">setupWorker</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>handlers<span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p><strong>Worker 등록 및 실행</strong></p>\n<p>개발 환경에서만 MSW를 활성화하기 위해 조건을 설정하고, 애플리케이션 실행 전에 Worker를 등록합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// msw.ts</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">enableMocking</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">!==</span> <span class=\"token string\">\"development\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span>\n <span class=\"token punctuation\">}</span>\n\n <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> worker <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./mocks/browser\"</span><span class=\"token punctuation\">)</span>\n\n <span class=\"token keyword\">return</span> worker<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// index.tsx</span>\n<span class=\"token keyword\">const</span> root <span class=\"token operator\">=</span> ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">createRoot</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"root\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">enableMocking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n root\n   <span class=\"token punctuation\">.</span>render\n   <span class=\"token comment\">// 애플리케이션 컴포넌트</span>\n   <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n</ol>\n<h3><strong>3. 콘솔에서 확인하기</strong></h3>\n<p>애플리케이션을 실행한 후, 개발자 도구의 콘솔에서 MSW가 정상적으로 작동하는지 확인합니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/team-blog/static/fd20d6ff228922b2d308dcfea2bf5969/b842e/console-1-image.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 34.11764705882353%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEklEQVR42l1QSXLEIAz0a7ywCrEZjPEy9rgqlxzz/59EnkkOSZcohKRuITXXde37fhzH8oN1zN6toBEEF0JwKcV9cc4YG/6iyTmXUhAxxlBr9d47ayGMxt0uoncuUMQYVEqRAmm8hUizIcL5eCBATtOUE9UqrQ0BgI5WVitKaoMWnacQeYCWKujZuBDrecG4aD1KfTMkGOHHVxEC/QJRgWHouPXMepmrTEWmWcSpGQYW6gdOhw4RyHw0IZrt1GU1Mdllp6CeN1hPlWfYnjBV4YIIiRo0fdel7XO+vlJ8aJLnnIYZhGCSNnX7ZIymNZZpwwFpiX3bEqvve+o8+LHk+oypuqmknInftd0/vAht90t74xtXy1I3R7CCdQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='console 1 image' title='' src='/team-blog/static/fd20d6ff228922b2d308dcfea2bf5969/ca1dc/console-1-image.png' srcset='/team-blog/static/fd20d6ff228922b2d308dcfea2bf5969/e7570/console-1-image.png 170w,\n/team-blog/static/fd20d6ff228922b2d308dcfea2bf5969/f46e7/console-1-image.png 340w,\n/team-blog/static/fd20d6ff228922b2d308dcfea2bf5969/ca1dc/console-1-image.png 680w,\n/team-blog/static/fd20d6ff228922b2d308dcfea2bf5969/02d09/console-1-image.png 1020w,\n/team-blog/static/fd20d6ff228922b2d308dcfea2bf5969/b842e/console-1-image.png 1142w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>잘 작동하네요! 😮😮</p>\n<h3><strong>4. Mocking하지 않은 API 처리하기</strong></h3>\n<p>그런데 콘솔에는 많은 경고가 존재하고 있었어요.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/team-blog/static/eb41f5a81a4b6bb43096d283176cf036/2d324/console-2-image.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 15.88235294117647%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAn0lEQVR42jWN3Q6CIABGfRhb5lQycUNLpYIU5EdQ1Lbe/zmii7azc3e+L+A4tqpwGi66mOVlnaD3ZkqPm6ARuRoAJ8n4SkWf9fe4rcKuDvH14AlIF5kRaAaMKKyEm0XOoFmV+1yvBm22kiwfaepjRhLfywFofvZz/SMOOM0+b+IsXne9LEzyWqtOiUaLRonbpLBgiOKI4tPfP/zlsz1+AeEwLts6Mx/OAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='console 2 image' title='' src='/team-blog/static/eb41f5a81a4b6bb43096d283176cf036/ca1dc/console-2-image.png' srcset='/team-blog/static/eb41f5a81a4b6bb43096d283176cf036/e7570/console-2-image.png 170w,\n/team-blog/static/eb41f5a81a4b6bb43096d283176cf036/f46e7/console-2-image.png 340w,\n/team-blog/static/eb41f5a81a4b6bb43096d283176cf036/ca1dc/console-2-image.png 680w,\n/team-blog/static/eb41f5a81a4b6bb43096d283176cf036/02d09/console-2-image.png 1020w,\n/team-blog/static/eb41f5a81a4b6bb43096d283176cf036/2d324/console-2-image.png 1306w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>이를 알아본 결과, MSW는 정의되지 않은 API 요청을 모두 캐치해 경고를 출력한다고 해요.</p>\n<div align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/team-blog/static/e9acb4f8772e23aa561b6aede7bb84d0/ca756/console-3-image.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 53.529411764705884%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKUlEQVR42nWRSY6DQAxFuQMEmmJo5hkWURiiIHH/W+VRbkrJov/Csl22v/3Ler1ey7Ks67rv+/P5fDwenufdNBzHuV3Ad13X+4bVNM0wDH3fY8dxJEyS5FcjTdMsyxKNsiyjKKLhR+OvWSlVFEWe51KBpUcydV1XVYXDiK7rgiCwbRt+2ehsbtuWUtOAJUMPKxQahPjMZRariaWSKRZ1xMymDj+O4+CC0gi+IRnsybxtG5rd7/d5no/jYCS7fd7m/oOzGZ24B+ZPPeGfpon1wjCUpBHJzAWWKEwpDcS+7/OMsKIWT2K52YRGdotPQmFuoM2sylXySdj8gujCLobfghOpCfwLZNlC2ETkRgMH5aEVzag8bxbdzUn4vEEitPILOAyCRpYnVEq9AYLkUnKTmJuHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='console 3 image' title='' src='/team-blog/static/e9acb4f8772e23aa561b6aede7bb84d0/ca1dc/console-3-image.png' srcset='/team-blog/static/e9acb4f8772e23aa561b6aede7bb84d0/e7570/console-3-image.png 170w,\n/team-blog/static/e9acb4f8772e23aa561b6aede7bb84d0/f46e7/console-3-image.png 340w,\n/team-blog/static/e9acb4f8772e23aa561b6aede7bb84d0/ca1dc/console-3-image.png 680w,\n/team-blog/static/e9acb4f8772e23aa561b6aede7bb84d0/02d09/console-3-image.png 1020w,\n/team-blog/static/e9acb4f8772e23aa561b6aede7bb84d0/ca756/console-3-image.png 1296w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</div>\n<p>따라서 onUnhandledRequest 옵션을 bypass로 설정하여 정의되지 않은 API 요청은 무시하도록 설정했어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\">worker<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> onUnhandledRequest<span class=\"token operator\">:</span> <span class=\"token string\">\"bypass\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2>폴더 구조를 잡아봅시다.</h2>\n<p>간단하게 테스트해 본 결과, msw도입을 위해 필요한 파일들은 크게 3가지 종류로 나눌 수 있었어요.</p>\n<ol>\n<li>API 핸들러</li>\n<li>Mock 데이터</li>\n<li>브라우저 환경에서 실행할 수 있게 도와주는 Worker함수</li>\n</ol>\n<p>따라서 각 파일들을 어떤 디렉터리에 위치시킬지 생각해보았어요.</p>\n<h3>방법 1: API 경로 기반 구조</h3>\n<p>첫번째로 고려한 방식은 API 주소를 기준으로 폴더를 구성하는 방식이에요.</p>\n<p>예를 들어 <code class=\"language-text\">http://localhost/test/verification</code>이라는 API를 Mocking한다고 했을 때, 파일구조는 아래와 같이 작성됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">src\n├── __mocks__/\n│   ├── localhost/\n│   │   └── test/\n│   │       └── verification\n│   ├── handlers.ts\n│   └── browser.ts</code></pre></div>\n<p><strong>장점은 다음과 같아요.</strong></p>\n<ul>\n<li><strong>직관적인 경로:</strong> API 경로를 기반으로 하는 구조는 파일 시스템에서 해당 API를 쉽게 찾을 수 있게 해줍니다. 이는 특히 큰 프로젝트에서 API를 빠르게 찾아 수정해야 할 때 유용해요.</li>\n<li><strong>변경 관리 용이:</strong> 특정 API에 대한 변경 사항이 있을 때, 관련 파일을 찾아 수정하기가 간편합니다.</li>\n</ul>\n<p><strong>단점은 다음과 같아요.</strong></p>\n<ul>\n<li><strong>중복된 구조:</strong> 여러 API가 비슷한 데이터 구조를 공유할 경우, 코드와 mock 데이터의 중복이 발생할 수 있습니다.</li>\n<li><strong>스케일링 문제:</strong> 프로젝트 규모가 커지면 폴더 구조가 깊어지고 복잡해질 수 있습니다.</li>\n</ul>\n<h3>방법 2: Mock 데이터 중심 구조</h3>\n<p>두번째로 고려해 본 방식은 Mock 데이터만 별도로 관리하고 핸들러는 한 곳에 모으는 방식입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">src\n├── server/\n│   ├── __mocks__/\n│   │   └── userList.ts/\n│   ├── handlers.ts\n│   └── browser.ts</code></pre></div>\n<p><strong>장점은 다음과 같아요.</strong></p>\n<ul>\n<li><strong>데이터 중심:</strong> 공통된 데이터 구조를 사용하는 API들이 많은 경우, mock 데이터를 중앙에서 관리함으로써 중복을 줄일 수 있습니다.</li>\n<li><strong>유연성:</strong> 데이터 변경이 필요할 때 한 곳에서 관리하기 때문에, 데이터의 일관성을 유지하기가 용이합니다.</li>\n</ul>\n<p><strong>단점은 다음과 같아요.</strong></p>\n<ul>\n<li><strong>핸들러 관리:</strong> 모든 핸들러를 한 곳에 모으게 되면, 파일이 방대해지고 관리가 어려워질 수 있습니다.</li>\n<li><strong>데이터와 핸들러의 분리:</strong> 데이터와 핸들러가 분리되어 있어, 관련 핸들러와 데이터 사이의 연결을 파악하기 어려울 수 있습니다.</li>\n</ul>\n<h3>방법 3: 도메인별 구조</h3>\n<p>세번째로 고려한 방식은 도메인별로 핸들러와 데이터를 모아두는 방식이에요.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">src\n├── mocks/\n│   ├── domain/\n│   │   └── album/\n│   │       ├── data.ts\n│   │       └── handlers.ts\n│   ├── handlers.ts\n│   └── browser.ts</code></pre></div>\n<p><strong>장점은 다음과 같아요.</strong></p>\n<ul>\n<li><strong>도메인 중심:</strong> 서비스의 기능별로 구분되어 있어, 관련 기능을 개발할 때 모든 관련 파일을 쉽게 찾을 수 있습니다.</li>\n<li><strong>유지보수 용이:</strong> 각 도메인별로 핸들러와 데이터를 분리함으로써, 유지보수가 용이합니다. 특정 기능에 문제가 생겼을 때, 해당 도메인의 폴더만 확인하면 됩니다.</li>\n<li><strong>확장성:</strong> 새로운 기능이나 도메인이 추가될 때, 새로운 폴더를 만들어 그 안에 모든 관련 파일을 배치함으로써 확장성이 높습니다.</li>\n</ul>\n<p><strong>단점은 다음과 같아요.</strong></p>\n<ul>\n<li><strong>공통 데이터 관리:</strong> 여러 도메인에서 공통적으로 사용되는 데이터가 있을 경우, 이를 어떻게 관리할지 고민이 필요합니다.</li>\n<li><strong>API 간 데이터 공유의 어려움:</strong> 특정 도메인에서만 사용되는 데이터가 아닌, 전역적으로 사용되는 데이터의 경우, 어느 도메인에 속해야 할지 결정하기 어려울 수 있습니다.</li>\n</ul>\n<h3>그로잉은요?</h3>\n<p>그로잉 서비스는 각 기능별로 구분된 도메인이 명확하기 때문에, 3번 방식이 가장 적합하다고 판단했어요.</p>\n<p>그리고 기존에 외부 라이브러리는 libs폴더에 정의해두고 사용했지만, msw 관련 파일은 mocks폴더에 전부 모아두기로 했어요. 빌드시 필요없는 코드와 파일들을 한 곳에 몰아넣기 위함이에요.</p>\n<p>또한 3번 방식처럼 도메인별 핸들러 함수를 한 파일에 전부 정의해두는 것보다는 분리한 후 index 파일에서 취합해서 내보내기로 했어요. API별 데이터들과 params, 200일때, 400일때 케이스들을 한 파일에 모두 작성하면 코드의 길이가 너무 길어져서 가독성을 해칠 것이라고 판단했기 때문이에요.</p>\n<p>따라서 아래와 같이 폴더 구조를 정할 수 있었어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">src\n├── mocks/\n│   ├── user/\n│   │   ├── index.ts\n│   │   ├── getUserHandler.ts\n│   │   └── anotherHandler.ts\n│   ├── handlers.ts // 도메인별 핸들러 함수를 모두 취합하는 곳이에요.\n│   ├── browser.ts // worker를 정의해 둔 파일이에요.\n│   └── msw.ts // enableMocking() 함수를 정의해 둔 파일이에요.</code></pre></div>\n<p>아래는 예시입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// mocks/user/getUserHandler.ts</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Params</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> data<span class=\"token operator\">:</span> UserDto <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span>\n  nickName<span class=\"token operator\">:</span> <span class=\"token string\">\"곰곰곰\"</span><span class=\"token punctuation\">,</span>\n  birthDay<span class=\"token operator\">:</span> <span class=\"token string\">\"2000-01-01\"</span><span class=\"token punctuation\">,</span>\n  anniversaryDay<span class=\"token operator\">:</span> <span class=\"token string\">\"2023-12-16\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getUserHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  http<span class=\"token punctuation\">.</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Params<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> UserDto<span class=\"token punctuation\">,</span> <span class=\"token string\">\"/user/:userId\"</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"/user/:userId\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> params <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> params\n\n      <span class=\"token keyword\">await</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">return</span> HttpResponse<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// mocks/user/index.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> getUserHandler <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./getUserHandler\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> anotherHandler <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./anotherHandler\"</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> UserHandlers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>getUserHandler<span class=\"token punctuation\">,</span> anotherHandler<span class=\"token punctuation\">]</span></code></pre></div>\n<p>그러나 이 방식은 일부 도메인에는 적용할 수 없었어요.</p>\n<p>GET, POST, DELETE 하는 API 가 같은 데이터를 바라봐야 했기 때문이죠. 만약 기존 데이터를 DELETE 요청으로 지운 후에 GET 요청을 했을 때, 지운 데이터가 남아 있다면 테스트할 때 불편하다고 판단했어요.</p>\n<h3>최최최최종.jpg</h3>\n<p>따라서 데이터를 공유해야하는 API 들은 한 파일 안에 작성해두는 것으로 변경했어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">src\n├── mocks/\n│   ├── user/\n│   │   ├── getUserHandler.ts // 데이터를 공유할 필요없는 API\n│   │   ├── ...\n│   │   └── index.ts\n│   ├── chat/\n│   │   ├── data/\n│   │   │   ├── chatData.ts // 공유할 데이터\n│   │   │   └── image.png\n│   │   ├── chatHandler.ts // 공유할 데이터들을 사용하는 API들\n│   │   ├── chatQuestionHandler.ts\n│   │   └── index.ts\n│   ├── handlers.ts\n│   └── browser.ts</code></pre></div>\n<h2>에러 응답 목업은 어떻게 하지? 🤔</h2>\n<p>애플리케이션은 완벽할 수 없습니다. 네트워크 에러나 우리가 미처 처리하지 못한 예외 등으로 인해 생각한 대로 동작하지 않기도 해요. 그렇기 때문에 성공적인 응답만 mocking하는 것으로는 부족합니다. 이번 절에서는 에러 응답에 대한 모킹 방법에 대해 알아볼게요.</p>\n<h3>MSW 공식 문서 살펴보기</h3>\n<p>MSW의 공식 문서에서 다음과 같은 에러 응답 목업 방식에 대해 찾을 수 있었어요.</p>\n<ul>\n<li>\n<p>status code 설정하기</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> handlers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\nhttp<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/posts/:id\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> params <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> id <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> params\n  <span class=\"token keyword\">const</span> deletedPost <span class=\"token operator\">=</span> allPosts<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>deletedPost<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HttpResponse</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">status</span><span class=\"token operator\">:</span> <span class=\"token number\">404</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  allPosts<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> HttpResponse<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span>deletedPost<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>→ 조건에 따라 에러를 나타내는 status를 함께 반환하는 방식이에요.</p>\n</li>\n<li>\n<p>Network Error</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> http<span class=\"token punctuation\">,</span> HttpResponse <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"msw\"</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> handlers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\nhttp<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/resource\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> HttpResponse<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>→ 네트워크 에러의 경우 위와 같이 HttpResponse.error()를 반환해요.</p>\n</li>\n<li>\n<p>dynamic mock scenarios</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> http<span class=\"token punctuation\">,</span> HttpResponse <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"msw\"</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> scenarios <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n<span class=\"token literal-property property\">success</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n  http<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/user\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> HttpResponse<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"minju\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token literal-property property\">error</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n  http<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/user\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HttpResponse</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">status</span><span class=\"token operator\">:</span> <span class=\"token number\">500</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>→ 응답에 성공하는 경우와, 에러인 경우를 시나리오로 작성할 수 있어요. url 뒤에 <code class=\"language-text\">?scenario=error</code> 을 붙이면 오류 응답을 반환하는 경우에 어떻게 작동하는지 런타임에서 확인할 수 있어요.</p>\n</li>\n</ul>\n<h3>그로잉에서 선택한 에러 목업</h3>\n<p>저희는 런타임에서 여러 기능들의 성공과 실패의 조합에 따라 테스트를 할 수 있는 방식이 필요했어요. msw에서 제공해주는 dynamic mock scenarios를 사용해 이를 구현하려면 url이 바뀌여야 하고, 한 페이지에 있는 여러 기능에 대해 각 시나리오를 식별하도록 코드를 추가로 작성해야 합니다. 그래서 저희는 status code를 런타임에 다르게 설정하는 방식을 사용하기로 했고, 여러 조합을 편하게 테스트할 수 있게 도와주는 툴바를 제작하기로 했어요.</p>\n<br />\n<blockquote>\n<p>🤔 어떻게 MSW Toolbar를 만들었는지 궁금하다면? ➡️ <a href=\"https://teamgrowing.github.io/team-blog/msw-toolbar\">다음글에서 계속</a></p>\n</blockquote>","frontmatter":{"title":"MSW로 mocking을 해보자 ","date":"February 24, 2024","update":"February 24, 2024","tags":["growing","msw","mocking"],"series":"MSW Toolbar로 다양한 시나리오 테스트하기"},"fields":{"slug":"/msw/","readingTime":{"minutes":20.55}}},"seriesList":{"edges":[{"node":{"id":"4f66afb8-7a6a-512e-9059-cb8944da2816","fields":{"slug":"/msw/"},"frontmatter":{"title":"MSW로 mocking을 해보자 "}}},{"node":{"id":"c7f66eaa-90e0-519d-8f14-cc308cc82297","fields":{"slug":"/msw-toolbar/"},"frontmatter":{"title":"API 요청 시뮬레이션을 간편하게: 그로잉 팀의 MSW Toolbar 도입기"}}}]},"previous":{"fields":{"slug":"/folder-structure/"},"frontmatter":{"title":"행복한 개발을 위한 폴더 구조는?"}},"next":{"fields":{"slug":"/msw-toolbar/"},"frontmatter":{"title":"API 요청 시뮬레이션을 간편하게: 그로잉 팀의 MSW Toolbar 도입기"}}},"pageContext":{"id":"4f66afb8-7a6a-512e-9059-cb8944da2816","series":"MSW Toolbar로 다양한 시나리오 테스트하기","previousPostId":"32a5f287-3449-5bba-b35b-575c54ec9291","nextPostId":"c7f66eaa-90e0-519d-8f14-cc308cc82297"}},"staticQueryHashes":[],"slicesMap":{}}